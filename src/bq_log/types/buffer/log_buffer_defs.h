#pragma once
/*
 * Copyright (C) 2024 THL A29 Limited, a Tencent company.
 * BQLOG is licensed under the Apache License, Version 2.0.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 */
/*!
 * It's not base class of bq::siso_ring_buffer and bq::miso_ring_buffer. But a simple code file with some data type definitions.
 * so, please don't include this header file, just include "log_buffer.h".
 *
 * \author pippocao
 * \date 2024/12/17
 */
#include <stddef.h>
#include "bq_common/bq_common.h"
#include "bq_log/misc/bq_log_api.h"
#if BQ_JAVA
#include <jni.h>
#endif

#ifndef NDEBUG
#define BQ_LOG_BUFFER_DEBUG 1
#else
#define BQ_LOG_BUFFER_DEBUG 0
#endif

namespace bq {
    static constexpr size_t CACHE_LINE_SIZE = 64;
    static constexpr size_t CACHE_LINE_SIZE_LOG2 = 6;
    static constexpr uint32_t BATCH_FREQUENCY= 1024;

    //Warning ! You Must Ensure The Alignment By Yourself!
    template<typename TO, typename FROM>
    bq_forceinline TO& __ring_buffer_force_cast_ignore_alignment_warning(FROM* from)
    {
#if BQ_GCC 
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Waddress-of-packed-member"
#elif BQ_CLANG
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Waddress-of-packed-member"
#elif BQ_MSVC
#pragma warning(push)
#pragma warning(disable : 4324)
#endif
        return *reinterpret_cast<TO*>(from);
#if BQ_GCC
#pragma GCC diagnostic pop
#elif BQ_CLANG
#pragma clang diagnostic pop
#elif BQ_MSVC
#pragma warning(pop)
#endif
    }

    #define BUFFER_ATOMIC_CAST_IGNORE_ALIGNMENT(X, TYPE) bq::__ring_buffer_force_cast_ignore_alignment_warning<bq::platform::atomic<TYPE>>(&X)


    struct log_buffer_handle_base {
        uint8_t* data_addr;
        enum_buffer_result_code result = enum_buffer_result_code::err_alloc_size_invalid;
    };

    struct log_buffer_write_handle : public log_buffer_handle_base {
        bool low_space_flag = false; // just approximate because of multi-thread
    };

    struct log_buffer_read_handle : public log_buffer_handle_base {
        uint32_t data_size;
    };

    enum create_memory_map_result {
        failed,
        use_existed,
        new_created
    };

    /// <summary>
    /// Configuration settings for creating and managing a log buffer.
    /// </summary>
    struct log_buffer_config {
        bq::string log_name;
        bq::array<bq::string> log_categories_name;

        /// <summary>The initial size of the buffer in bytes. Depending on the type, this can signify the total buffer
        /// size(normal) or the size per thread(high_performance). In some cases, the actual size might be adjusted to be larger than
        /// this initial value.</summary>
        uint32_t default_buffer_size = 1024 * 64;

        /// <summary>Specifies whether memory-mapped files are used for buffer storage to support
        /// data recovery. That if program is killed without process the left data in log buffer. it will not
        ///  be lost in most cases and can be recovered when program is relaunched.</summary>
        bool use_mmap = false;

        /// <summary>Memory policy when space is not enough.</summary>
        bq::log_memory_policy policy = log_memory_policy::block_when_full;

        /// <summary>
        /// If a thread writes more than this threshold of logs per second on a specific log object, 
        /// it will be considered high-frequency logging and will have a dedicated buffer.
        /// </summary>
        uint64_t high_frequency_threshold_per_second = UINT64_MAX;

        /// <summary>
        /// Used to verify whether a memory mapping file is generated by a specified log object.
        /// </summary>
        /// <returns></returns>
        uint64_t calculate_check_sum() const
        {
            bq::string verify_str = log_name + "/";
            for (const auto& category_name : log_categories_name) {
                verify_str += category_name + "/";
            }
            uint64_t check_sum = verify_str.hash_code();
            return check_sum;
        }
    };

    
    template<typename BUFFER_TYPE>
    class scoped_log_buffer_handle {
    private:
        BUFFER_TYPE* buffer_;
        log_buffer_read_handle read_handle_;
        log_buffer_write_handle write_handle_;
        bool is_read_handle_;

    public:
        scoped_log_buffer_handle() = delete;
        bq_forceinline scoped_log_buffer_handle(BUFFER_TYPE& buffer, log_buffer_read_handle& handle)
            : buffer_(&buffer)
            , read_handle_(handle)
            , is_read_handle_(true)
        {
            (void)write_handle_;
        }
        bq_forceinline scoped_log_buffer_handle(BUFFER_TYPE& buffer, log_buffer_write_handle& handle)
            : buffer_(&buffer)
            , write_handle_(handle)
            , is_read_handle_(false)
        {
            (void)read_handle_;
        }
        bq_forceinline ~scoped_log_buffer_handle()
        {
            if (is_read_handle_) {
                buffer_->return_read_trunk(read_handle_);
            } else {
                buffer_->commit_write_chunk(write_handle_);
            }
        }
    };
}
