#pragma once
/*
 * Copyright (C) 2024 THL A29 Limited, a Tencent company.
 * BQLOG is licensed under the Apache License, Version 2.0.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 */
/*!
 * It's not base class of bq::siso_ring_buffer and bq::miso_ring_buffer. But a simple code file with some data type definitions.
 * so, please don't include this header file, just include "log_buffer.h".
 *
 * \author pippocao
 * \date 2024/12/17
 */
#include <stddef.h>
#include "bq_common/bq_common.h"
#include "bq_log/misc/bq_log_api.h"
#if BQ_JAVA
#include <jni.h>
#endif

#ifndef NDEBUG
#define BQ_LOG_BUFFER_DEBUG 1
#else
#define BQ_LOG_BUFFER_DEBUG 0
#endif

#if BQ_GCC
#elif BQ_CLANG
#elif BQ_MSVC
#pragma warning(disable : 4324)
#endif

namespace bq {
    static constexpr size_t CACHE_LINE_SIZE_LOG2 = 6;

    #define BUFFER_ATOMIC_CAST_IGNORE_ALIGNMENT(X, TYPE) BQ_PACK_ACCESS_BY_TYPE(X, bq::platform::atomic<TYPE>)  

    #define BQ_POD_RUNTIME_OFFSET_OF(Type, Field) (((size_t)&(((Type*)0x10000)->Field)) - (size_t)0x10000)
    
    BQ_PACK_BEGIN
    struct alignas(16) log_buffer_write_handle{
        uint8_t* data_addr;
        enum_buffer_result_code result = enum_buffer_result_code::err_empty_log_buffer;
        bool low_space_flag = false; // just approximate because of multi-thread
    } 
    BQ_PACK_END 

    BQ_PACK_BEGIN 
    struct alignas(16) log_buffer_read_handle {
        uint8_t* data_addr;
        enum_buffer_result_code result = enum_buffer_result_code::err_empty_log_buffer;
        uint32_t data_size;
    } 
    BQ_PACK_END

    enum create_memory_map_result {
        failed,
        use_existed,
        new_created
    };

    /// <summary>
    /// Configuration settings for creating and managing a log buffer.
    /// </summary>
    struct log_buffer_config {
        bq::string log_name;
        bq::array<bq::string> log_categories_name;

        /// <summary>The initial size of the buffer in bytes. Depending on the type, this can signify the total buffer
        /// size(normal) or the size per thread(high_performance). In some cases, the actual size might be adjusted to be larger than
        /// this initial value.</summary>
#if BQ_ANDROID || BQ_IOS
        uint32_t default_buffer_size = 1024 * 32;
#else
        uint32_t default_buffer_size = 1024 * 64;
#endif

        /// <summary>Specifies whether memory-mapped files are used for buffer storage to support
        /// data recovery. That if program is killed without process the left data in log buffer. it will not
        ///  be lost in most cases and can be recovered when program is relaunched.</summary>
        bool need_recovery = false;

        /// <summary>Memory policy when space is not enough.</summary>
        bq::log_memory_policy policy = log_memory_policy::block_when_full;

        /// <summary>
        /// If a thread writes more than this threshold of logs per second on a specific log object, 
        /// it will be considered high-frequency logging and will have a dedicated buffer.
        /// </summary>
        uint64_t high_frequency_threshold_per_second = 1000;

        /// <summary>
        /// Used to verify whether a memory mapping file is generated by a specified log object.
        /// </summary>
        /// <returns></returns>
        uint64_t calculate_check_sum() const
        {
            bq::string verify_str = log_name + "/";
            for (const auto& category_name : log_categories_name) {
                verify_str += category_name + "/";
            }
            uint64_t check_sum = verify_str.hash_code();
            return check_sum;
        }
    };

    
    template<typename BUFFER_TYPE>
    class scoped_log_buffer_handle {
        enum class destruction_type : uint8_t {
            return_chunk,
            commit_chunk,
        };
    private:
        BUFFER_TYPE* buffer_;
        log_buffer_read_handle read_handle_;
        log_buffer_write_handle write_handle_;
        destruction_type destruction_type_;

    public:
        scoped_log_buffer_handle() = delete;
        scoped_log_buffer_handle(BUFFER_TYPE& buffer, const log_buffer_read_handle& handle);
        scoped_log_buffer_handle(BUFFER_TYPE& buffer, const log_buffer_write_handle& handle);
        ~scoped_log_buffer_handle();
    };

    template <typename BUFFER_TYPE>
    bq::scoped_log_buffer_handle<BUFFER_TYPE>::scoped_log_buffer_handle(BUFFER_TYPE& buffer, const log_buffer_write_handle& handle)
        : buffer_(&buffer)
        , read_handle_(log_buffer_read_handle())
        , write_handle_(handle)
        , destruction_type_(destruction_type::commit_chunk)
    {
        (void)read_handle_;
    }

    template <typename BUFFER_TYPE>
    scoped_log_buffer_handle<BUFFER_TYPE>::~scoped_log_buffer_handle()
    {
        switch (destruction_type_) {
        case destruction_type::return_chunk:
            buffer_->return_read_chunk(read_handle_);
            break;
        case destruction_type::commit_chunk:
            buffer_->commit_write_chunk(write_handle_);
            break;
        default:
            break;
        }
    }

    template <typename BUFFER_TYPE>
    bq::scoped_log_buffer_handle<BUFFER_TYPE>::scoped_log_buffer_handle(BUFFER_TYPE& buffer, const log_buffer_read_handle& handle)
        : buffer_(&buffer)
        , read_handle_(handle)
        , write_handle_(log_buffer_write_handle())
        , destruction_type_(destruction_type::return_chunk)
    {
        (void)write_handle_;
    }
}
