#include "K2Node_BqLog.h"
#include "BqLogFunctionLibrary.h"
#include "BqLog.h"

#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "Kismet2/BlueprintEditorUtils.h"
#include "KismetCompiler.h"
#include "K2Node_CallFunction.h"
#include "K2Node_MakeArray.h"
#include "K2Node_MakeStruct.h"
#include "Kismet/KismetStringLibrary.h"
#include "Kismet/KismetTextLibrary.h"
#include "EdGraphSchema_K2.h"

#if WITH_EDITOR
#include "ToolMenus.h"
#include "GraphEditorActions.h"
#include "Framework/Commands/UIAction.h"
#include "ScopedTransaction.h"
#endif

const FName UK2Node_BqLogFormat::LogInstancePinName(TEXT("LogInstance"));
const FName UK2Node_BqLogFormat::LogLevelPinName(TEXT("LogLevel"));
const FName UK2Node_BqLogFormat::LogFormatStringPinName(TEXT("Log Format String"));
const FName UK2Node_BqLogFormat::CategoryPinName(TEXT("Category"));
const FName UK2Node_BqLogFormat::ArgPinPrefix(TEXT("Arg"));
const FName UK2Node_BqLogFormat::ReturnPinName(TEXT("Success"));

FText UK2Node_BqLogFormat::GetNodeTitle(ENodeTitleType::Type) const
{
    return NSLOCTEXT("BqLog", "BqLogFormat", "BqLog (Format Support)");
}

FText UK2Node_BqLogFormat::GetTooltipText() const
{
    return NSLOCTEXT("BqLog", "BqLogFormatTooltip", "Output BqLog with or without formatted arguments.");
}

FSlateIcon UK2Node_BqLogFormat::GetIconAndTint(FLinearColor& OutColor) const
{
#if ENGINE_MAJOR_VERSION >= 5
    static FSlateIcon Icon("EditorStyle", "Kismet.AllClasses.FunctionIcon");
#else
    static FSlateIcon Icon("EditorStyle", "Kismet.AllClasses.FunctionIcon");
#endif
    OutColor = FLinearColor::White;
    return Icon;
}

void UK2Node_BqLogFormat::PostLoad()
{
    Super::PostLoad();
    RefreshCategoryPinStatus();
}


void UK2Node_BqLogFormat::AllocateDefaultPins()
{
    CreatePin(EGPD_Input,  UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);
    CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);

    UEdGraphPin* LogInstancePin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Object, UBqLog::StaticClass(), LogInstancePinName);
    LogInstancePin->bNotConnectable = false;
    
    LogInstancePin->PinType.PinSubCategoryObject = UBqLog::StaticClass();

    UEdGraphPin* LogLevelPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Byte, StaticEnum<EBqLogLevel>(), LogLevelPinName);
    LogLevelPin->DefaultValue = TEXT("Info"); 

    UEdGraphPin* LogFormatStringPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_String, LogFormatStringPinName);
    LogFormatStringPin->DefaultValue = TEXT("");

    bool bShouldShow = false;
    if (SavedLogType.GetDefaultObject())
    {
        bShouldShow = SavedLogType.GetDefaultObject()->SupportsCategoryEnum();
    }

    if (bShouldShow)
    {
        UEnum* CategoryEnum = SavedLogType.GetDefaultObject()->GetCategoryEnum();
        if (CategoryEnum)
        {
            UEdGraphPin* CategoryPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Byte, CategoryEnum, CategoryPinName);
            if (CategoryPin)
            {
                const int64 DefaultVal = CategoryEnum->GetValueByName(TEXT("Default"));
                const FString DefaultLiteral = CategoryEnum->GetNameStringByValue(DefaultVal);
                const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();
                K2Schema->TrySetDefaultValue(*CategoryPin, DefaultLiteral);
                CategoryPin->AutogeneratedDefaultValue = DefaultLiteral;
            }
        }
    }

    for (const FName& ArgName : ArgumentNames)
    {
        CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Wildcard, ArgName);
    }
    
    CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Boolean, ReturnPinName);
}


UEdGraphPin* UK2Node_BqLogFormat::GetLogExecutePin() const { return FindPinChecked(UEdGraphSchema_K2::PN_Execute, EGPD_Input); }
UEdGraphPin* UK2Node_BqLogFormat::GetLogThenPin() const { return FindPinChecked(UEdGraphSchema_K2::PN_Then, EGPD_Output); }
UEdGraphPin* UK2Node_BqLogFormat::GetLogInstancePin() const { return FindPinChecked(LogInstancePinName, EGPD_Input); }
UEdGraphPin* UK2Node_BqLogFormat::GetLogLevelPin() const { return FindPinChecked(LogLevelPinName, EGPD_Input); }
UEdGraphPin* UK2Node_BqLogFormat::GetLogFormatStringPin() const { return FindPinChecked(LogFormatStringPinName, EGPD_Input); }

void UK2Node_BqLogFormat::AddInputPin()
{
#if WITH_EDITOR
    const FScopedTransaction Transaction(NSLOCTEXT("BqLog", "AddArgumentPin", "Add Argument Pin"));
    FBlueprintEditorUtils::MarkBlueprintAsStructurallyModified(GetBlueprint());
#endif
    FName NewArgName = GetUniqueArgumentName();
    ArgumentNames.Add(NewArgName);
    ReconstructNode();
}

bool UK2Node_BqLogFormat::CanAddPin() const
{
    return true;
}

bool UK2Node_BqLogFormat::CanRemovePin(const UEdGraphPin* Pin) const
{
    if (!Pin || Pin->Direction != EGPD_Input) 
    {
        return false;
    }
    
    if (Pin->PinName == UEdGraphSchema_K2::PN_Execute || Pin->PinName == LogInstancePinName || Pin->PinName == LogFormatStringPinName) 
    {
        return false;
    }
    
    if (!Pin->PinName.ToString().StartsWith(ArgPinPrefix.ToString()))
    {
        return false;
    }
    return true;
}

void UK2Node_BqLogFormat::RemoveArgumentPin(UEdGraphPin* Pin)
{
    if (!Pin)
    {
        return;
    }
    if (!CanRemovePin(Pin))
    {
        return;
    }
#if WITH_EDITOR
    const FScopedTransaction Transaction(NSLOCTEXT("BqLog", "RemoveArgumentPin", "Remove Argument Pin"));
    FBlueprintEditorUtils::MarkBlueprintAsStructurallyModified(GetBlueprint());
#endif
    RemoveInputPin(Pin);
}

// UE5 Details Panel Support
void UK2Node_BqLogFormat::GetNodeContextMenuActions(UToolMenu* Menu, UGraphNodeContextMenuContext* Context) const
{
    Super::GetNodeContextMenuActions(Menu, Context);
    if (Context && Context->Node)
    {
        FToolMenuSection& Section = Menu->AddSection("BqLogActions", NSLOCTEXT("BqLog", "BqLogActions", "BqLog Actions"));
        
        Section.AddMenuEntry(
            "AddArgument",
            NSLOCTEXT("BqLog", "AddArgument", "Add Argument"),
            NSLOCTEXT("BqLog", "AddArgumentTooltip", "Add a new argument pin"),
            FSlateIcon(),
            FUIAction(FExecuteAction::CreateLambda([this]() {
                const_cast<UK2Node_BqLogFormat*>(this)->AddInputPin();
            }))
        );

        TArray<UEdGraphPin*> ArgPins;
        GetArgPins(const_cast<TArray<UEdGraphPin*>&>(ArgPins));
        
        for (int32 i = 0; i < ArgPins.Num(); ++i)
        {
            UEdGraphPin* Pin = ArgPins[i];
            if (Pin && CanRemovePin(Pin))
            {
                Section.AddMenuEntry(
                    *FString::Printf(TEXT("RemoveArgument_%d"), i),
                    FText::Format(NSLOCTEXT("BqLog", "RemoveArgument", "Remove {0}"), FText::FromName(Pin->PinName)),
                    FText::Format(NSLOCTEXT("BqLog", "RemoveArgumentTooltip", "Remove argument {0}"), FText::FromName(Pin->PinName)),
                    FSlateIcon(),
                    FUIAction(FExecuteAction::CreateLambda([this, Pin]() {
#if WITH_EDITOR
                        const FScopedTransaction Transaction(NSLOCTEXT("BqLog", "RemoveArgumentPin", "Remove Argument Pin"));
#endif
                        const_cast<UK2Node_BqLogFormat*>(this)->RemoveArgumentPin(Pin);
                    }))
                );
            }
        }
    }
}

#if WITH_EDITOR
int32 UK2Node_BqLogFormat::GetNumArguments() const
{
    int32 Count = 0;
    for (UEdGraphPin* Pin : Pins)
    {
        if (Pin->Direction == EGPD_Input && Pin->PinName.ToString().StartsWith(ArgPinPrefix.ToString()))
        {
            ++Count;
        }
    }
    return Count;
}

void UK2Node_BqLogFormat::AddArgument()
{
    AddInputPin();
}

void UK2Node_BqLogFormat::RemoveArgument(int32 Index)
{
    int32 CurrentIndex = 0;
    for (UEdGraphPin* Pin : Pins)
    {
        if (Pin->Direction == EGPD_Input && Pin->PinName.ToString().StartsWith(ArgPinPrefix.ToString()))
        {
            if (CurrentIndex == Index)
            {
                RemoveArgumentPin(Pin);
                break;
            }
            ++CurrentIndex;
        }
    }
}

bool UK2Node_BqLogFormat::CanRemoveArgument(int32 Index) const
{
    int32 ArgCount = GetNumArguments();
    bool CanRemove = (ArgCount > 0 && Index >= 0 && Index < ArgCount);
    return CanRemove;
}
#endif

void UK2Node_BqLogFormat::RemoveInputPin(UEdGraphPin* Pin)
{
    if (!Pin || Pin->Direction != EGPD_Input) return;
    if (Pin->PinName == UEdGraphSchema_K2::PN_Execute || Pin->PinName == LogInstancePinName || Pin->PinName == LogFormatStringPinName) return;
    if (Pin->PinName.ToString().StartsWith(ArgPinPrefix.ToString()) || Pin->PinName.ToString().Equals(CategoryPinName.ToString()))
    {
        ArgumentNames.Remove(Pin->PinName);
        PinsToPurge.Add(Pin->PinName);
        Modify();
        Pin->BreakAllPinLinks();
        ReconstructNode();
        FBlueprintEditorUtils::MarkBlueprintAsStructurallyModified(GetBlueprint());
        if (UEdGraph* Graph = GetGraph()) { 
#if ENGINE_MAJOR_VERSION >= 5
            Graph->NotifyNodeChanged(this);
#else
            Graph->NotifyGraphChanged();
#endif
        }
    }
}

void UK2Node_BqLogFormat::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
    UClass* ActionKey = GetClass();
    if (ActionRegistrar.IsOpenForRegistration(ActionKey))
    {
        ActionRegistrar.AddBlueprintAction(ActionKey, UBlueprintNodeSpawner::Create(ActionKey));
    }
}

FText UK2Node_BqLogFormat::GetMenuCategory() const
{
    return NSLOCTEXT("BqLog", "BqLogCategory", "BqLog");
}

void UK2Node_BqLogFormat::ValidateNodeDuringCompilation(FCompilerResultsLog& MessageLog) const
{
    Super::ValidateNodeDuringCompilation(MessageLog);
    if (UEdGraphPin* CatPin = const_cast<UK2Node_BqLogFormat*>(this)->FindPin(CategoryPinName, EGPD_Input))
    {
        UEnum* CategoryEnum = Cast<UEnum>(CatPin->PinType.PinSubCategoryObject.Get());
        if (!CategoryEnum)
        {
            return; 
        }
        if (CatPin->LinkedTo.Num() > 0)
        {
            return;
        }
        const FString NameStr = CatPin->DefaultValue;
        int32 Index = INDEX_NONE;

        FString CleanName = NameStr;
        int32 SepPos = INDEX_NONE;
        if (CleanName.FindChar(':', SepPos))
        {
            int32 Pos = CleanName.Find(TEXT("::"));
            if (Pos != INDEX_NONE) CleanName = CleanName.Mid(Pos + 2);
        }

#if ENGINE_MAJOR_VERSION >= 5 || ENGINE_MINOR_VERSION >= 22
        Index = CategoryEnum->GetIndexByName(FName(CategoryEnum->GenerateEnumPrefix() + FString(TEXT("::")) + *CleanName));
#else
        Index = CategoryEnum->GetIndexByNameString(CategoryEnum->GenerateEnumPrefix() + FString(TEXT("::")) + CleanName);
#endif
        if (Index == INDEX_NONE)
        {
            MessageLog.Error(*NSLOCTEXT("BqLog", "Error_InvalidCategory", "Invalid Category selection on @@").ToString(), this);
            return;
        }
    }
}

void UK2Node_BqLogFormat::ReallocatePinsDuringReconstruction(TArray<UEdGraphPin*>& OldPins)
{
    if (!SavedLogType)
    {
        for (UEdGraphPin* Pin : OldPins)
        {
            if (Pin && Pin->Direction == EGPD_Input && Pin->PinName == LogInstancePinName)
            {
                UClass* Detected = nullptr;
                if (UObject* DefObj = Pin->DefaultObject)
                {
                    if (auto* AsLog = Cast<UBqLog>(DefObj))
                        Detected = AsLog->GetClass();
                }
                if (!Detected && Pin->LinkedTo.Num() > 0)
                {
                    if (UEdGraphPin* L = Pin->LinkedTo[0])
                    {
                        if (UClass* LinkedCls = Cast<UClass>(L->PinType.PinSubCategoryObject.Get()))
                        {
                            if (LinkedCls->IsChildOf(UBqLog::StaticClass()))
                                Detected = LinkedCls;
                        }
                    }
                }
                if (Detected)
                {
                    SavedLogType = Detected;
                }
                break;
            }
        }
    }
    for (int32 i = OldPins.Num() - 1; i >= 0; --i)
    {
        UEdGraphPin* P = OldPins[i];
        if (!P)
        {
            continue;
        }
        if (PinsToPurge.Contains(P->PinName))
        {
            P->BreakAllPinLinks();
            OldPins.RemoveAt(i);
        }
    }
    Super::ReallocatePinsDuringReconstruction(OldPins);
    PinsToPurge.Empty();
}

UEdGraphPin* UK2Node_BqLogFormat::CreateNextArgPin()
{
    int32 MaxIdx = -1;
    for (UEdGraphPin* P : Pins)
    {
        if (P->Direction == EGPD_Input &&
            P->PinName.ToString().StartsWith(ArgPinPrefix.ToString()))
        {
            int32 N = -1;
            LexTryParseString(N, *P->PinName.ToString().RightChop(ArgPinPrefix.ToString().Len()));
            MaxIdx = FMath::Max(MaxIdx, N);
        }
    }
    const int32 NewIdx = MaxIdx + 1;
    UEdGraphPin* NewPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Wildcard, *FString::Printf(TEXT("%s%d"), *ArgPinPrefix.ToString(), NewIdx));
    NewPin->bNotConnectable = false;
    return NewPin;
}

void UK2Node_BqLogFormat::GetArgPins(TArray<UEdGraphPin*>& OutPins) const
{
    for (UEdGraphPin* P : Pins)
    {
        if (P->Direction == EGPD_Input &&
            P->PinName.ToString().StartsWith(ArgPinPrefix.ToString()))
        {
            OutPins.Add(P);
        }
    }
    OutPins.Sort([this](const UEdGraphPin& A, const UEdGraphPin& B){
        int32 IA = -1, IB = -1;
        LexTryParseString(IA, *A.PinName.ToString().RightChop(ArgPinPrefix.ToString().Len()));
        LexTryParseString(IB, *B.PinName.ToString().RightChop(ArgPinPrefix.ToString().Len()));
        return IA < IB;
    });
}

FName UK2Node_BqLogFormat::GetArgNameFromPin(const UEdGraphPin* Pin)
{
    if (Pin && Pin->PinFriendlyName.IsEmpty() == false)
        return FName(*Pin->PinFriendlyName.ToString());
    return Pin ? Pin->PinName : NAME_None;
}

void UK2Node_BqLogFormat::NotifyPinConnectionListChanged(UEdGraphPin* Pin)
{
    Super::NotifyPinConnectionListChanged(Pin);
    if (!Pin || Pin->Direction != EGPD_Input) return;
    
    if (Pin->PinName == LogInstancePinName)
    {
        OnLogInstanceChanged();
        return;
    }
    
    if (Pin->PinName == LogFormatStringPinName || Pin->PinName == UEdGraphSchema_K2::PN_Execute || Pin->PinName == LogInstancePinName) return;

    if (Pin->LinkedTo.Num() > 0)
    {
        const UEdGraphPin* Other = Pin->LinkedTo[0];
        Pin->PinType = Other->PinType; 
    }
    else
    {
        Pin->PinType.PinCategory = UEdGraphSchema_K2::PC_Wildcard;
        Pin->PinType.PinSubCategoryObject = nullptr;
        Pin->DefaultValue.Reset();
    }
}

void UK2Node_BqLogFormat::PinDefaultValueChanged(UEdGraphPin* Pin)
{
    Super::PinDefaultValueChanged(Pin);
    if (!Pin)
    {
        return;
    }
    if (Pin->PinName == LogInstancePinName)
    {
        OnLogInstanceChanged();
        return;
    }
}

void UK2Node_BqLogFormat::ExpandNode(FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
    Super::ExpandNode(CompilerContext, SourceGraph);
    const UEdGraphSchema_K2* Schema = CompilerContext.GetSchema();

    UEdGraphPin* LogInstancePin = GetLogInstancePin();
    const bool bHasConnection = (LogInstancePin && LogInstancePin->LinkedTo.Num() > 0);
    const bool bHasDefaultObj = (LogInstancePin && LogInstancePin->DefaultObject != nullptr);
    if (!bHasConnection && !bHasDefaultObj)
    {
        CompilerContext.MessageLog.Error(TEXT("LogInstance must be set on @@"), this);
        return;
    }

    TArray<UEdGraphPin*> ArgPins;
    GetArgPins(ArgPins);

    TArray<UEdGraphPin*> AnyStructOutputs;
    AnyStructOutputs.Reserve(ArgPins.Num());

    for (UEdGraphPin* ArgPin : ArgPins)
    {
        UK2Node_MakeStruct* MakeAny = CompilerContext.SpawnIntermediateNode<UK2Node_MakeStruct>(this, SourceGraph);
        MakeAny->bMadeAfterOverridePinRemoval = true;
        MakeAny->StructType = FBqLogAny::StaticStruct();
        MakeAny->AllocateDefaultPins();

        const UEdGraphPin* TypeSrc = (ArgPin->LinkedTo.Num() > 0 ? ArgPin->LinkedTo[0] : ArgPin);
        const FName Cat = TypeSrc->PinType.PinCategory;
        UObject* SubObj = TypeSrc->PinType.PinSubCategoryObject.Get();

        auto SetTypeEnum = [&](EBqLogAnyType E)
        {
            if (UEdGraphPin* TypePin = MakeAny->FindPin(TEXT("Type"), EGPD_Input))
            {
                FString EnumName = StaticEnum<EBqLogAnyType>()->GetNameStringByValue((int64)E);
                CompilerContext.GetSchema()->TrySetDefaultValue(*TypePin, EnumName);
            }
        };

        if (Cat == UEdGraphSchema_K2::PC_Boolean)
        {
            SetTypeEnum(EBqLogAnyType::Bool);
            if (UEdGraphPin* P = MakeAny->FindPin(TEXT("B"), EGPD_Input))
            {
                CompilerContext.MovePinLinksToIntermediate(*ArgPin, *P);
            }
        }
        else if (Cat == UEdGraphSchema_K2::PC_Int)
        {
            SetTypeEnum(EBqLogAnyType::Int32);
            if (UEdGraphPin* P = MakeAny->FindPin(TEXT("I32"), EGPD_Input))
            {
                CompilerContext.MovePinLinksToIntermediate(*ArgPin, *P);
            }
        }
        else if (Cat == UEdGraphSchema_K2::PC_Int64)
        {
            SetTypeEnum(EBqLogAnyType::Int64);
            if (UEdGraphPin* P = MakeAny->FindPin(TEXT("I64"), EGPD_Input))
            {
                CompilerContext.MovePinLinksToIntermediate(*ArgPin, *P);
            }
        }
        else if (Cat == UEdGraphSchema_K2::PC_Float)
        {
            SetTypeEnum(EBqLogAnyType::Float);
            if (UEdGraphPin* P = MakeAny->FindPin(TEXT("F"), EGPD_Input))
            {
                CompilerContext.MovePinLinksToIntermediate(*ArgPin, *P);
            }
        }
#if ENGINE_MAJOR_VERSION >= 5
        else if (Cat == UEdGraphSchema_K2::PC_Real)
        {
            // SetTypeEnum(EBqLogAnyType::Double);
            // if (UEdGraphPin* P = MakeAny->FindPin(TEXT("D"), EGPD_Input))
            // {
            //     CompilerContext.MovePinLinksToIntermediate(*ArgPin, *P);
            // }
            SetTypeEnum(EBqLogAnyType::Float);
            if (UEdGraphPin* P = MakeAny->FindPin(TEXT("F"), EGPD_Input))
            {
                CompilerContext.MovePinLinksToIntermediate(*ArgPin, *P);
            }
        }
#endif
        else if (Cat == UEdGraphSchema_K2::PC_String)
        {
            SetTypeEnum(EBqLogAnyType::String);
            if (UEdGraphPin* P = MakeAny->FindPin(TEXT("S"), EGPD_Input))
            {
                CompilerContext.MovePinLinksToIntermediate(*ArgPin, *P);
            }
        }
        else if (Cat == UEdGraphSchema_K2::PC_Name)
        {
            SetTypeEnum(EBqLogAnyType::Name);
            if (UEdGraphPin* P = MakeAny->FindPin(TEXT("N"), EGPD_Input))
            {
                CompilerContext.MovePinLinksToIntermediate(*ArgPin, *P);
            }
        }
        else if (Cat == UEdGraphSchema_K2::PC_Text)
        {
            SetTypeEnum(EBqLogAnyType::Text);
            if (UEdGraphPin* P = MakeAny->FindPin(TEXT("T"), EGPD_Input))
            {
                CompilerContext.MovePinLinksToIntermediate(*ArgPin, *P);
            }
        }
        else if (Cat == UEdGraphSchema_K2::PC_Object)
        {
            SetTypeEnum(EBqLogAnyType::Object);
            if (UEdGraphPin* P = MakeAny->FindPin(TEXT("Obj"), EGPD_Input))
            {
                CompilerContext.MovePinLinksToIntermediate(*ArgPin, *P);
            }
        }
        else if (Cat == UEdGraphSchema_K2::PC_Class)
        {
            SetTypeEnum(EBqLogAnyType::Class);
            if (UEdGraphPin* P = MakeAny->FindPin(TEXT("Cls"), EGPD_Input))
            {
                CompilerContext.MovePinLinksToIntermediate(*ArgPin, *P);
            }
        }
        else if (Cat == UEdGraphSchema_K2::PC_SoftObject
              || (Cat == UEdGraphSchema_K2::PC_Struct && SubObj == TBaseStructure<FSoftObjectPath>::Get()))
        {
            SetTypeEnum(EBqLogAnyType::SoftObject);
            if (UEdGraphPin* P = MakeAny->FindPin(TEXT("SoftPath"), EGPD_Input))
            {
                CompilerContext.MovePinLinksToIntermediate(*ArgPin, *P);
            }
        }
        else if (Cat == UEdGraphSchema_K2::PC_Struct && SubObj)
        {
            UScriptStruct* SStruct = Cast<UScriptStruct>(SubObj);
            if (SStruct == TBaseStructure<FVector>::Get())
            {
                SetTypeEnum(EBqLogAnyType::Vector);
                if (UEdGraphPin* P = MakeAny->FindPin(TEXT("V"), EGPD_Input))
                {
                    CompilerContext.MovePinLinksToIntermediate(*ArgPin, *P);
                }
            }
            else if (SStruct == TBaseStructure<FRotator>::Get())
            {
                SetTypeEnum(EBqLogAnyType::Rotator);
                if (UEdGraphPin* P = MakeAny->FindPin(TEXT("R"), EGPD_Input))
                {
                    CompilerContext.MovePinLinksToIntermediate(*ArgPin, *P);
                }
            }
            else if (SStruct == TBaseStructure<FTransform>::Get())
            {
                SetTypeEnum(EBqLogAnyType::Transform);
                if (UEdGraphPin* P = MakeAny->FindPin(TEXT("Xform"), EGPD_Input))
                {
                    CompilerContext.MovePinLinksToIntermediate(*ArgPin, *P);
                }
            }
            else if (SStruct == TBaseStructure<FColor>::Get())
            {
                SetTypeEnum(EBqLogAnyType::Color);
                if (UEdGraphPin* P = MakeAny->FindPin(TEXT("Color"), EGPD_Input))
                {
                    CompilerContext.MovePinLinksToIntermediate(*ArgPin, *P);
                }
            }
            else if (SStruct == TBaseStructure<FLinearColor>::Get())
            {
                SetTypeEnum(EBqLogAnyType::LinearColor);
                if (UEdGraphPin* P = MakeAny->FindPin(TEXT("LColor"), EGPD_Input))
                {
                    CompilerContext.MovePinLinksToIntermediate(*ArgPin, *P);
                }
            }
            else
            {
                SetTypeEnum(EBqLogAnyType::String);
                if (UEdGraphPin* P = MakeAny->FindPin(TEXT("S"), EGPD_Input))
                {
                    CompilerContext.GetSchema()->TrySetDefaultValue(*P, SubObj->GetName());
                }
            }
        }
        else
        {
            SetTypeEnum(EBqLogAnyType::String);
            if (UEdGraphPin* P = MakeAny->FindPin(TEXT("S"), EGPD_Input))
            {
                CompilerContext.GetSchema()->TrySetDefaultValue(*P, SubObj ? SubObj->GetName() : TEXT(""));
            }
        }

        UEdGraphPin* OutPin = nullptr;
        for (UEdGraphPin* P : MakeAny->Pins)
        {
            if (P->Direction == EGPD_Output) { OutPin = P; break; }
        }
        check(OutPin);
        AnyStructOutputs.Add(OutPin);
    }

    const int32 Desired = AnyStructOutputs.Num();
    UK2Node_MakeArray* MakeArrayAny = nullptr;

    if (Desired > 0)
    {
        MakeArrayAny = CompilerContext.SpawnIntermediateNode<UK2Node_MakeArray>(this, SourceGraph);
        MakeArrayAny->AllocateDefaultPins();

        UEdGraphPin* OutArr = MakeArrayAny->GetOutputPin();
        OutArr->PinType.PinCategory = UEdGraphSchema_K2::PC_Struct;
        OutArr->PinType.PinSubCategoryObject = FBqLogAny::StaticStruct();
        OutArr->PinType.ContainerType = EPinContainerType::Array;

        auto CollectArrayInputs = [](UK2Node_MakeArray* Node, TArray<UEdGraphPin*>& OutInputs)
        {
            OutInputs.Reset();
            for (UEdGraphPin* P : Node->Pins)
            {
                if (P && P->Direction == EGPD_Input)
                {
                    OutInputs.Add(P);
                }
            }
        };

        TArray<UEdGraphPin*> ArrayInputs;
        CollectArrayInputs(MakeArrayAny, ArrayInputs);

        int32 Safety = 128;
        while (ArrayInputs.Num() < Desired && Safety-- > 0)
        {
            MakeArrayAny->AddInputPin();
            CollectArrayInputs(MakeArrayAny, ArrayInputs);
        }

        for (UEdGraphPin* InPin : ArrayInputs)
        {
            InPin->PinType = OutArr->PinType;
            InPin->PinType.ContainerType = EPinContainerType::None;
        }

        const int32 ConnectCount = FMath::Min(Desired, ArrayInputs.Num());
        for (int32 i = 0; i < ConnectCount; ++i)
        {
            Schema->TryCreateConnection(AnyStructOutputs[i], ArrayInputs[i]);
        }
    }

    UK2Node_CallFunction* CallSubmit = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);
    CallSubmit->SetFromFunction(UBqLogFunctionLibrary::StaticClass()->FindFunctionByName(
        Desired > 0 ? GET_FUNCTION_NAME_CHECKED(UBqLogFunctionLibrary, DoBqLogFormat)
                    : GET_FUNCTION_NAME_CHECKED(UBqLogFunctionLibrary, DoBqLog)));
    CallSubmit->AllocateDefaultPins();

    UEdGraphPin* CallLogInstancePin   = CallSubmit->FindPin(TEXT("LogInstance"),   EGPD_Input);
    UEdGraphPin* CallLogLevelPin      = CallSubmit->FindPin(TEXT("Level"),         EGPD_Input);
    UEdGraphPin* CallCategoryIndexPin = CallSubmit->FindPin(TEXT("CategoryIndex"), EGPD_Input);
    UEdGraphPin* CallFormatStringPin  = CallSubmit->FindPin(TEXT("FormatString"),  EGPD_Input);

    if (!(CallLogInstancePin && CallLogLevelPin && CallCategoryIndexPin && CallFormatStringPin))
    {
        CompilerContext.MessageLog.Error(TEXT("Internal error: Missing pins on function node @@"), this);
        BreakAllNodeLinks();
        return;
    }

    CompilerContext.MovePinLinksToIntermediate(*GetLogInstancePin(),    *CallLogInstancePin);
    CompilerContext.MovePinLinksToIntermediate(*GetLogLevelPin(),       *CallLogLevelPin);
    CompilerContext.MovePinLinksToIntermediate(*GetLogFormatStringPin(),*CallFormatStringPin);

    if (UEdGraphPin* CategoryPin = FindPin(CategoryPinName, EGPD_Input))
    {
        if (CategoryPin->LinkedTo.Num() > 0)
        {
            Schema->TryCreateConnection(CategoryPin, CallCategoryIndexPin);
        }
        else
        {
            UEnum* CategoryEnum = Cast<UEnum>(CategoryPin->PinType.PinSubCategoryObject.Get());
            if (!CategoryEnum)
            {
                CompilerContext.MessageLog.Error(TEXT("Category enum type is missing on @@"), this);
                BreakAllNodeLinks();
                return;
            }

            auto LastToken = [](const FString& S)->FString {
                int32 Pos = S.Find(TEXT("::"), ESearchCase::CaseSensitive, ESearchDir::FromEnd);
                return (Pos != INDEX_NONE) ? S.Mid(Pos + 2) : S;
            };

            const FString RawName = CategoryPin->DefaultValue;
            const FString ShortName = LastToken(RawName);

#if (ENGINE_MAJOR_VERSION > 4) || (ENGINE_MAJOR_VERSION == 4 && ENGINE_MINOR_VERSION >= 22)
            int32 Index = CategoryEnum->GetIndexByName(FName(*ShortName));
#else
            int32 Index = CategoryEnum->GetIndexByNameString(ShortName);
#endif
            if (Index == INDEX_NONE)
            {
                CompilerContext.MessageLog.Error(TEXT("Invalid Category selection on @@"), this);
                BreakAllNodeLinks();
                return;
            }
            const int64 Value = CategoryEnum->GetValueByIndex(Index);
            CompilerContext.GetSchema()->TrySetDefaultValue(*CallCategoryIndexPin, LexToString((int32)Value));
        }
    }
    else
    {
        CompilerContext.GetSchema()->TrySetDefaultValue(*CallCategoryIndexPin, TEXT("0"));
    }

    if (Desired > 0)
    {
        if (UEdGraphPin* CallArgsPin = CallSubmit->FindPin(TEXT("Args"), EGPD_Input))
        {
            Schema->TryCreateConnection(MakeArrayAny->GetOutputPin(), CallArgsPin);
        }
    }


    UEdGraphPin* ThisReturnPin = FindPinChecked(ReturnPinName, EGPD_Output);
    UEdGraphPin* CallReturnPin = CallSubmit->FindPin(UEdGraphSchema_K2::PN_ReturnValue, EGPD_Output);
    CompilerContext.MovePinLinksToIntermediate(*ThisReturnPin, *CallReturnPin);
    
    UEdGraphPin* ThisExec = GetLogExecutePin();
    UEdGraphPin* ThisThen = GetLogThenPin();
    if (!ThisExec || !ThisThen || !CallSubmit->GetExecPin() || !CallSubmit->GetThenPin())
    {
        CompilerContext.MessageLog.Error(TEXT("Internal error: Exec/Then pins missing on @@"), this);
        BreakAllNodeLinks();
        return;
    }
    CompilerContext.MovePinLinksToIntermediate(*ThisExec, *CallSubmit->GetExecPin());
    CompilerContext.MovePinLinksToIntermediate(*ThisThen, *CallSubmit->GetThenPin());

    BreakAllNodeLinks();
}

void UK2Node_BqLogFormat::PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent)
{
    const FName PropertyName = (PropertyChangedEvent.Property ? PropertyChangedEvent.Property->GetFName() : NAME_None);
    
    if (PropertyName == GET_MEMBER_NAME_CHECKED(UK2Node_BqLogFormat, ArgumentNames))
    {
        ReconstructNode();
    }
    
    Super::PostEditChangeProperty(PropertyChangedEvent);
    if (UEdGraph* Graph = GetGraph())
    {
#if ENGINE_MAJOR_VERSION >= 5
        Graph->NotifyNodeChanged(this);
#else
        Graph->NotifyGraphChanged();
#endif
    }
}

void UK2Node_BqLogFormat::OnLogInstanceChanged()
{
    RefreshCategoryPinStatus();
    const bool bShouldShowCategory = SavedLogType.GetDefaultObject() ? SavedLogType.GetDefaultObject()->SupportsCategoryEnum() : false;
    UEdGraphPin* ExistingCategoryPin = FindPin(CategoryPinName, EGPD_Input);
    const bool bCurrentlyHasCategory = (ExistingCategoryPin != nullptr);

    bool bNeedReconstruct = false;
    if (bShouldShowCategory && ExistingCategoryPin)
    {
        UEnum* NewEnum = SavedLogType.GetDefaultObject()->GetCategoryEnum();
        UEnum* OldEnum = Cast<UEnum>(ExistingCategoryPin->PinType.PinSubCategoryObject.Get());
        if (NewEnum != OldEnum)
        {
            bNeedReconstruct = true;
        }
    }
    if (bShouldShowCategory != bCurrentlyHasCategory)
    {
        bNeedReconstruct = true;
    }
    if (bNeedReconstruct)
    {
        UEdGraphPin* CategoryPin = FindPin(CategoryPinName, EGPD_Input);
        if (CategoryPin)
        {
            RemoveInputPin(CategoryPin);
        }
        ReconstructNode();
        FBlueprintEditorUtils::MarkBlueprintAsStructurallyModified(GetBlueprint());
    }
}


void UK2Node_BqLogFormat::RefreshCategoryPinStatus()
{
    SavedLogType = nullptr;
    UEdGraphPin* LogInstancePin = GetLogInstancePin();
    if (LogInstancePin)
    {
        if (LogInstancePin->LinkedTo.Num() > 0)
        {
            UEdGraphPin* ConnectedPin = LogInstancePin->LinkedTo[0];
            if (ConnectedPin)
            {
                if (UClass* Cls = Cast<UClass>(ConnectedPin->PinType.PinSubCategoryObject.Get()))
                {
                    if (Cls->IsChildOf(UBqLog::StaticClass()))
                    {
                        SavedLogType = Cls;
                    }
                }
            }
        }

        if (LogInstancePin->DefaultObject)
        {
            const UBqLog* LogInstance = Cast<UBqLog>(LogInstancePin->DefaultObject);
            auto Cls = LogInstancePin->DefaultObject->GetClass();
            if (Cls->IsChildOf(UBqLog::StaticClass()))
            {
                SavedLogType = Cls;
            }
        }
    }
}

FName UK2Node_BqLogFormat::GetUniqueArgumentName() const
{
    FName NewArgName;
    int32 i = 0;
    while (true)
    {
        NewArgName = *FString::Printf(TEXT("Arg%d"), i++);
        if (!ArgumentNames.Contains(NewArgName))
        {
            break;
        }
    }
    return NewArgName;
}