name: AutoTest

on:
  workflow_dispatch:  # manually trigger
    inputs:
      run_arm_tests:
        description: 'Run slow ARM test jobs'
        required: false
        type: boolean
        default: false
  workflow_call:
jobs:
  #Windows
  win64:
    runs-on: ${{ matrix.runner.runs_on }}
    strategy:
      fail-fast: false
      matrix:
        cc: [ msvc, clang, mingw_clang, mingw_gcc ]
        cpp_ver: [ 11, 14, 17, 20, 23 ]
        runner:
          - label: "x86_64"
            runs_on: windows-latest
          - label: "arm64"
            runs_on: windows-11-arm
        exclude:
          - cc: mingw_gcc
            runner: 11-arm

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'

      - name: Install Clang(Attempt 1)
        if: ${{ matrix.runner.runs_on == 'windows-11-arm' }}
        continue-on-error: true
        shell: bash
        run: |
          choco uninstall -y llvm --all-versions || true
          choco install -y llvm
      - name: Install Clang(Attempt 2)
        if: ${{ matrix.runner.runs_on == 'windows-11-arm' }}
        continue-on-error: true
        shell: bash
        run: |
          choco install -y llvm
      - name: Install Clang(Attempt 3)
        if: ${{ matrix.runner.runs_on == 'windows-11-arm' }}
        continue-on-error: true
        shell: bash
        run: |
          choco install -y llvm

      - name: Install MSYS2
        if: ${{ matrix.cc == 'mingw_gcc' }}
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          release: true
          path-type: inherit
          update: true

      - name: Ensure MSYS2 packages (Attempt 1)
        if: ${{ matrix.cc == 'mingw_gcc' }}
        continue-on-error: true
        shell: msys2 {0}
        run: |
          pacman -S --noconfirm --needed --overwrite '*' mingw-w64-x86_64-gcc mingw-w64-x86_64-binutils mingw-w64-x86_64-make
          echo "MSYS2 Root: $MSYSTEM_CARCH"
          which gcc
          which mingw32-make
      - name: Ensure MSYS2 packages (Attempt 2)
        if: ${{ matrix.cc == 'mingw_gcc' }}
        continue-on-error: true
        shell: msys2 {0}
        run: |
          pacman -S --noconfirm --needed --overwrite '*' mingw-w64-x86_64-gcc mingw-w64-x86_64-binutils mingw-w64-x86_64-make
          echo "MSYS2 Root: $MSYSTEM_CARCH"
          which gcc
          which mingw32-make
      - name: Ensure MSYS2 packages (Attempt 3)
        if: ${{ matrix.cc == 'mingw_gcc' }}
        continue-on-error: true
        shell: msys2 {0}
        run: |
          pacman -S --noconfirm --needed --overwrite '*' mingw-w64-x86_64-gcc mingw-w64-x86_64-binutils mingw-w64-x86_64-make
          echo "MSYS2 Root: $MSYSTEM_CARCH"
          which gcc
          which mingw32-make

      - name: Remove conflicting MinGW paths
        if: ${{ matrix.cc == 'mingw_gcc' }}
        run: |
          $env:Path = $env:Path -replace 'C:\\mingw64\\bin;','' -replace 'C:\\Program Files\\Git\\mingw64\\bin;',''
          echo "PATH=$env:Path" >> $env:GITHUB_ENV
        shell: powershell
      - name: Add MSYS2 to PATH
        if: ${{ matrix.cc == 'mingw_gcc' }}
        run: |
          $env:Path = "${{ steps.msys2.outputs.msys2-location }}\mingw64\bin;" + $env:Path
          echo "PATH=$env:Path" >> $env:GITHUB_ENV
        shell: powershell

      - name: Enable WER LocalDumps (BqLogUnitTest.exe)
        shell: powershell
        run: |
          $ErrorActionPreference = "Stop"
          $dumpDir = Join-Path $env:GITHUB_WORKSPACE "win_dumps"
          New-Item -ItemType Directory -Force -Path $dumpDir | Out-Null
          Write-Host "Dump dir: $dumpDir"

          # Use HKCU to avoid requiring elevated permissions.
          $key = "HKCU:\Software\Microsoft\Windows\Windows Error Reporting\LocalDumps\BqLogUnitTest.exe"
          New-Item -Force -Path $key | Out-Null
          New-ItemProperty -Path $key -Name DumpFolder -PropertyType ExpandString -Value $dumpDir -Force | Out-Null
          New-ItemProperty -Path $key -Name DumpType   -PropertyType DWord       -Value 2       -Force | Out-Null  # 2 = full dump
          New-ItemProperty -Path $key -Name DumpCount  -PropertyType DWord       -Value 10      -Force | Out-Null

          Get-ItemProperty -Path $key | Format-List

      - name: Build for Windows
        id: win_run_tests
        continue-on-error: true
        shell: powershell
        run: |
          $ErrorActionPreference = "Continue"

          cd build\test\win64
          # Avoid any interactive `pause` hanging CI.
          cmd /c "call .\run_test_${{ matrix.cc }}.bat ${{ matrix.cpp_ver }} <nul"
          $code = $LASTEXITCODE
          "exitcode=$code" >> $env:GITHUB_OUTPUT
          Write-Host "BqLogUnitTest exitcode=$code"
          exit 0

      - name: Print crash stack from dump (cdb)
        if: steps.win_run_tests.outputs.exitcode != '0'
        shell: powershell
        run: |
          $ErrorActionPreference = "Continue"
          $dumpDir = Join-Path $env:GITHUB_WORKSPACE "win_dumps"
          Write-Host "Dump dir: $dumpDir"
          $dumps = Get-ChildItem -Path $dumpDir -Filter *.dmp -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending
          if (-not $dumps) {
            Write-Host "No .dmp found (process may have terminated without WER dump)."
            exit 0
          }

          $dump = $dumps[0].FullName
          Write-Host "Using dump: $dump"

          $cdb = (Get-Command cdb.exe -ErrorAction SilentlyContinue).Source
          if (-not $cdb) {
            $candidates = @(
              "C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\cdb.exe",
              "C:\Program Files (x86)\Windows Kits\11\Debuggers\x64\cdb.exe",
              "C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\cdb.exe",
              "C:\Program Files (x86)\Windows Kits\11\Debuggers\x86\cdb.exe"
            )
            foreach ($p in $candidates) { if (Test-Path $p) { $cdb = $p; break } }
          }

          if (-not $cdb) {
            Write-Host "cdb.exe not found, attempting to install WinDbg via Chocolatey..."
            choco install -y windbg --no-progress
            $cdb = (Get-Command cdb.exe -ErrorAction SilentlyContinue).Source
            if (-not $cdb) {
              $candidates = @(
                "C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\cdb.exe",
                "C:\Program Files (x86)\Windows Kits\11\Debuggers\x64\cdb.exe"
              )
              foreach ($p in $candidates) { if (Test-Path $p) { $cdb = $p; break } }
            }
          }

          if (-not $cdb) {
            Write-Host "Still no cdb.exe found. Dump will still be uploaded as artifact."
            exit 0
          }

          Write-Host "Using cdb: $cdb"
          Write-Host "=== cdb analysis begin ==="
          & $cdb -z $dump -c "!analyze -v; .ecxr; kv; q" 2>&1
          Write-Host "=== cdb analysis end ==="

      - name: Upload Windows crash dumps (if any)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: win_dumps_${{ matrix.runner.label }}_${{ matrix.cc }}_cpp${{ matrix.cpp_ver }}
          path: win_dumps/**
          if-no-files-found: ignore

      - name: Fail job if tests failed
        if: steps.win_run_tests.outputs.exitcode != '0'
        shell: powershell
        run: exit 1


  #Linux-ubuntu
  ubuntu:
    name: ubuntu (${{ matrix.runner.label }} ${{ matrix.cc }} ${{ matrix.cpp_ver }} ${{ matrix.asan.label }})
    runs-on: ${{ matrix.runner.runs_on }}
    strategy:
      fail-fast: false
      matrix:
        runner:
          - label: "x86_64"
            runs_on: ubuntu-latest
          - label: "arm64"
            runs_on: ubuntu-24.04-arm
        asan:
          - label: "asan"
            assan_switch: TRUE
          - label: " "
            assan_switch: FALSE
        cc: [ clang, gcc ]
        cpp_ver: [ 11, 14, 17, 20, 23 ]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'adopt'

      - name: Install GDB(Attempt 1)
        continue-on-error: true
        run: |
          sudo apt-get update && sudo apt-get install -y gdb
      - name: Install GDB(Attempt 2)
        continue-on-error: true
        run: |
          sudo apt-get update && sudo apt-get install -y gdb
      - name: Install GDB(Attempt 3)
        continue-on-error: true
        run: |
          sudo apt-get update && sudo apt-get install -y gdb       

      - name: Build for Linux
        env:
          BQ_ENABLE_ASAN: ${{ matrix.asan.assan_switch }}
        run: |
          cd build/test/linux  
          chmod +x *.sh
          ./run_test_${{ matrix.cc }}.sh ${{ matrix.cpp_ver }}

  #linux-debian
  debian:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        arch:
          - label: "x86_64"
            runs_on: ""
          - label: "x86"
            runs_on: "i386_"
        cc: [ clang, gcc ]
        cpp_ver: [ 11, 14, 17, 20, 23 ]
    container:
      image: ghcr.io/pippocao/bqlog/${{ matrix.arch.runs_on }}debian:latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install necessary tools (Attempt 1)
        continue-on-error: true
        run: |
          apt-get update
          apt-get install -y gcc clang g++ make cmake gdb
          apt-get install -y software-properties-common
          apt-get update
          apt-get install -y openjdk-17-jdk
          apt-get install -y openssh-client
      - name: Install necessary tools (Attempt 2)
        continue-on-error: true
        run: |
          apt-get update
          apt-get install -y gcc clang g++ make cmake gdb
          apt-get install -y software-properties-common
          apt-get update
          apt-get install -y openjdk-17-jdk
          apt-get install -y openssh-client
      - name: Install necessary tools (Attempt 3)
        continue-on-error: true
        run: |
          apt-get update
          apt-get install -y gcc clang g++ make cmake gdb
          apt-get install -y software-properties-common
          apt-get update
          apt-get install -y openjdk-17-jdk
          apt-get install -y openssh-client   

      - name: Set up Java
        run: |
          export JAVA_HOME=/usr/lib/jvm/java-17-openjdk-amd64
          echo "JAVA_HOME=/usr/lib/jvm/java-17-openjdk-amd64" >> $GITHUB_ENV

      - name: Build for Debian
        run: |
          cd build/test/linux  
          chmod +x *.sh
          ./run_test_${{ matrix.cc }}.sh ${{ matrix.cpp_ver }}

  #Mac
  mac_silicon:
    runs-on: macos-latest
    strategy:
      fail-fast: false
      matrix:
        asan:
          - label: "asan"
            assan_switch: TRUE
          - label: " "
            assan_switch: FALSE
        cpp_ver: [ 11, 14, 17, 20, 23 ]
    steps:
      - uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'adopt'

      - name: Build for macOS
        env:
          BQ_ENABLE_ASAN: ${{ matrix.asan.assan_switch }}
        run: |
          cd build/test/mac  
          chmod +x *.sh
          ./run_test.sh ${{ matrix.cpp_ver }}

  #Unix-FreeBSD
  freeBSD_x86_64:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        cc: [ gcc, clang ]
        cpp_ver: [ 11, 14, 17, 20, 23 ]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Free Disk Space (Ubuntu)
        uses: jlumbroso/free-disk-space@v1.3.1
        with:
          tool-cache: false
          android: true
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: true
          swap-storage: true

      - name: Run in FreeBSD(Attempt 1)
        continue-on-error: true
        uses: vmactions/freebsd-vm@v1
        with:
          usesh: true
          mem: 8192
          prepare: |
            for i in 1 2 3 4 5; do
              pkg install -y llvm cmake bash gdb gcc && exit 0
              echo "Install failed, retrying in 60s... ($i/5)"
              sleep 60
            done
            exit 1

          run: |
            touch UNIT_TEST_STARTED
            set -e -x
            cd build/test/unix_like  
            chmod +x *.sh
            ls -l
            ./run_test_${{ matrix.cc }}.sh ${{ matrix.cpp_ver }}
            touch ../../../UNIT_TEST_SUCCESS

      - name: Check Retry
        id: CheckRetry
        run: |
          if [ ! -f "UNIT_TEST_STARTED" ]; then
            echo "retry=true" >> $GITHUB_OUTPUT
          elif [ ! -f "UNIT_TEST_SUCCESS" ]; then
            echo "::error::Test script execution failed! (Not retrying)"
            exit 1
          fi
      - name: Cleanup Before Retry
        if: steps.CheckRetry.outputs.retry == 'true'
        run: |
          set +e 
          DOMAINS="$(sudo virsh list --all --name 2>/dev/null | grep -v "^$" || true)"
          if [ -z "$DOMAINS" ]; then
            echo "No lingering domains found (virsh may be unavailable or no domains exist)."
          else
            echo "Found domains: $DOMAINS"
            for DOMAIN in $DOMAINS; do
              echo "Processing domain: $DOMAIN"
              sudo virsh destroy "$DOMAIN" 2>/dev/null || echo "virsh destroy failed for $DOMAIN (ignored)"
              sudo virsh undefine "$DOMAIN" --nvram 2>/dev/null \
                || sudo virsh undefine "$DOMAIN" 2>/dev/null \
                || echo "virsh undefine failed for $DOMAIN (ignored)"
            done
          fi

          echo "--- Removing potentially corrupted VM images ---"
          find . -name "*.qcow2" -delete 2>/dev/null || echo "local qcow2 cleanup failed (ignored)"
          sudo find /home/runner/work/_actions/vmactions -name "*.qcow2" -delete 2>/dev/null || echo "vmactions qcow2 cleanup failed (ignored)"
          sudo rm -f /var/lib/libvirt/dnsmasq/*.leases 2>/dev/null || echo "dnsmasq leases cleanup failed (ignored)"
          sleep 5
          echo "Cleanup complete."

      - name: Run in FreeBSD(Attempt 2)
        if: steps.CheckRetry.outputs.retry == 'true'
        uses: vmactions/freebsd-vm@v1
        with:
          usesh: true
          mem: 8192
          prepare: |
            for i in 1 2 3 4 5; do
              pkg install -y llvm cmake bash gdb gcc && exit 0
              echo "Install failed, retrying in 60s... ($i/5)"
              sleep 60
            done
            exit 1

          run: |
            touch UNIT_TEST_STARTED
            set -e -x
            cd build/test/unix_like  
            chmod +x *.sh
            ls -l
            ./run_test_${{ matrix.cc }}.sh ${{ matrix.cpp_ver }}
            touch ../../../UNIT_TEST_SUCCESS

  freeBSD_arm64_test_cpp17:
    if: ${{ github.event.inputs.run_arm_tests == true || github.event.inputs.run_arm_tests == 'true' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        cc: [ gcc, clang ]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Free Disk Space (Ubuntu)
        uses: jlumbroso/free-disk-space@v1.3.1
        with:
          tool-cache: false
          android: true
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: true
          swap-storage: true

      - name: Run in FreeBSD(Attempt 1)
        continue-on-error: true
        uses: vmactions/freebsd-vm@v1
        with:
          arch: aarch64
          usesh: true
          mem: 8192
          prepare: |
            for i in 1 2 3 4 5; do
                pkg install -y llvm cmake bash gdb gcc13 && exit 0
                echo "Install failed, retrying in 60s... ($i/5)"
                sleep 60
            done
            exit 1
          run: |
            touch UNIT_TEST_STARTED
            set -e -x
            cd build/test/unix_like  
            chmod +x *.sh
            ls -l
            set +e
            ln -sf /usr/local/bin/gcc13 /usr/local/bin/gcc
            ln -sf /usr/local/bin/g++13 /usr/local/bin/g++
            ln -sf /usr/local/bin/gcov13 /usr/local/bin/gcov 2>/dev/null || true
            ln -sf /usr/local/bin/gcc-ar13 /usr/local/bin/gcc-ar 2>/dev/null || true
            ln -sf /usr/local/bin/gcc-ranlib13 /usr/local/bin/gcc-ranlib 2>/dev/null || true
            export LD_LIBRARY_PATH=/usr/local/lib/gcc13  #Adjust according to installed GCC version
            export BQ_LOW_PERFORMANCE_TESTS=true
            ./run_test_${{ matrix.cc }}.sh 17
            EXIT_CODE=$?
            set -e
            if [ $EXIT_CODE -ne 0 ]; then
              echo "Test failed with exit code $EXIT_CODE"
              CORE_FILE="$(find . -maxdepth 5 -type f \( -name 'core' -o -name 'core.*' -o -name '*.core' \) 2>/dev/null | head -n1)"
              EXE=""
              for cand in ./BqLogUnitTest ./BqLogUnitTest.exe $(find . -maxdepth 5 -type f -name 'BqLogUnitTest' 2>/dev/null | head -n1); do
                if [ -n "$cand" ] && [ -x "$cand" ]; then EXE="$cand"; break; fi
              done
              echo "exe: ${EXE:-<not found>}"
              echo "core: ${CORE_FILE:-<not found>}"
              if [ -n "$CORE_FILE" ] && [ -n "$EXE" ]; then
                echo "=== GDB core backtrace (FreeBSD aarch64) ==="
                gdb --batch -q \
                  -ex "set pagination off" \
                  -ex "info threads" \
                  -ex "thread apply all bt full" \
                  -ex "quit" \
                  "$EXE" "$CORE_FILE" || echo "gdb analysis failed"
              else
                echo "Core file or executable not found, listing candidates:"
                find . -maxdepth 5 -type f \( -name 'core' -o -name 'core.*' -o -name '*.core' -o -name 'BqLogUnitTest' \) 2>/dev/null || true
              fi
              exit $EXIT_CODE
            fi
            touch ../../../UNIT_TEST_SUCCESS

      - name: Check Retry
        id: CheckRetry
        run: |
          if [ ! -f "UNIT_TEST_STARTED" ]; then
            echo "retry=true" >> $GITHUB_OUTPUT
          elif [ ! -f "UNIT_TEST_SUCCESS" ]; then
            echo "::error::Test script execution failed! (Not retrying)"
            exit 1
          fi
      - name: Cleanup Before Retry
        if: steps.CheckRetry.outputs.retry == 'true'
        run: |
          set +e 
          DOMAINS="$(sudo virsh list --all --name 2>/dev/null | grep -v "^$" || true)"
          if [ -z "$DOMAINS" ]; then
            echo "No lingering domains found (virsh may be unavailable or no domains exist)."
          else
            echo "Found domains: $DOMAINS"
            for DOMAIN in $DOMAINS; do
              echo "Processing domain: $DOMAIN"
              sudo virsh destroy "$DOMAIN" 2>/dev/null || echo "virsh destroy failed for $DOMAIN (ignored)"
              sudo virsh undefine "$DOMAIN" --nvram 2>/dev/null \
                || sudo virsh undefine "$DOMAIN" 2>/dev/null \
                || echo "virsh undefine failed for $DOMAIN (ignored)"
            done
          fi

          echo "--- Removing potentially corrupted VM images ---"
          find . -name "*.qcow2" -delete 2>/dev/null || echo "local qcow2 cleanup failed (ignored)"
          sudo find /home/runner/work/_actions/vmactions -name "*.qcow2" -delete 2>/dev/null || echo "vmactions qcow2 cleanup failed (ignored)"
          sudo rm -f /var/lib/libvirt/dnsmasq/*.leases 2>/dev/null || echo "dnsmasq leases cleanup failed (ignored)"
          sleep 5
          echo "Cleanup complete."

      - name: Run in FreeBSD(Attempt 2)
        if: steps.CheckRetry.outputs.retry == 'true'
        uses: vmactions/freebsd-vm@v1
        with:
          arch: aarch64
          usesh: true
          mem: 8192
          prepare: |
            for i in 1 2 3 4 5; do
                pkg install -y llvm cmake bash gdb gcc13 && exit 0
                echo "Install failed, retrying in 60s... ($i/5)"
                sleep 60
            done
            exit 1
          run: |
            touch UNIT_TEST_STARTED
            set -e -x
            cd build/test/unix_like  
            chmod +x *.sh
            ls -l
            set +e
            ln -sf /usr/local/bin/gcc13 /usr/local/bin/gcc
            ln -sf /usr/local/bin/g++13 /usr/local/bin/g++
            ln -sf /usr/local/bin/gcov13 /usr/local/bin/gcov 2>/dev/null || true
            ln -sf /usr/local/bin/gcc-ar13 /usr/local/bin/gcc-ar 2>/dev/null || true
            ln -sf /usr/local/bin/gcc-ranlib13 /usr/local/bin/gcc-ranlib 2>/dev/null || true
            export LD_LIBRARY_PATH=/usr/local/lib/gcc13  #Adjust according to installed GCC version
            export BQ_LOW_PERFORMANCE_TESTS=true
            ./run_test_${{ matrix.cc }}.sh 17
            EXIT_CODE=$?
            set -e
            if [ $EXIT_CODE -ne 0 ]; then
              echo "Test failed with exit code $EXIT_CODE"
              CORE_FILE="$(find . -maxdepth 5 -type f \( -name 'core' -o -name 'core.*' -o -name '*.core' \) 2>/dev/null | head -n1)"
              EXE=""
              for cand in ./BqLogUnitTest ./BqLogUnitTest.exe $(find . -maxdepth 5 -type f -name 'BqLogUnitTest' 2>/dev/null | head -n1); do
                if [ -n "$cand" ] && [ -x "$cand" ]; then EXE="$cand"; break; fi
              done
              echo "exe: ${EXE:-<not found>}"
              echo "core: ${CORE_FILE:-<not found>}"
              if [ -n "$CORE_FILE" ] && [ -n "$EXE" ]; then
                echo "=== GDB core backtrace (FreeBSD aarch64) ==="
                gdb --batch -q \
                  -ex "set pagination off" \
                  -ex "info threads" \
                  -ex "thread apply all bt full" \
                  -ex "quit" \
                  "$EXE" "$CORE_FILE" || echo "gdb analysis failed"
              else
                echo "Core file or executable not found, listing candidates:"
                find . -maxdepth 5 -type f \( -name 'core' -o -name 'core.*' -o -name '*.core' -o -name 'BqLogUnitTest' \) 2>/dev/null || true
              fi
              exit $EXIT_CODE
            fi
            touch ../../../UNIT_TEST_SUCCESS          

  #Unix-Solaris
  solaris_x86_64_GCC:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        cpp_ver: [ 11, 14, 17, 20, 23 ]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Free Disk Space (Ubuntu)
        uses: jlumbroso/free-disk-space@v1.3.1
        with:
          tool-cache: false
          android: true
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: true
          swap-storage: true

      - name: Run in Solaris（Attempt 1）
        uses: vmactions/solaris-vm@v1
        continue-on-error: true
        with:
          usesh: true
          mem: 8192
          prepare: |
            for i in 1 2 3 4 5; do
              (
                pkg publisher && \
                pkg install -v --accept \
                  developer/build/cmake \
                  developer/build/gnu-make \
                  developer/debug/gdb \
                  developer/gcc-14 \
                  shell/bash
              ) && exit 0
              echo "Install failed, retrying in 60s... ($i/5)"
              sleep 60
            done
            exit 1
          run: |
            touch UNIT_TEST_STARTED
            ulimit -c unlimited
            set -e -x
            cd build/test/unix_like  
            chmod +x *.sh
            ls -l
            
            set +e
            ./run_test_gcc.sh ${{ matrix.cpp_ver }} 
            EXIT_CODE=$?
            set -e

            if [ $EXIT_CODE -ne 0 ]; then
                echo "Test failed with exit code $EXIT_CODE"
                echo "Waiting 30s for core dump to finish writing..."
                sleep 30
                CORE=$(find . -name core -type f | head -n 1)
                EXE=$(find . -name BqLogUnitTest -type f | head -n 1)
                if [ -n "$CORE" ] && [ -n "$EXE" ]; then
                    echo "=== GDB BACKTRACE ==="
                    echo "set pagination off" > gdb_cmds.txt
                    echo "thread apply all bt full" >> gdb_cmds.txt
                    echo "quit" >> gdb_cmds.txt
                    # Use perl for timeout (300s = 5min) to avoid CI hang
                    perl -e 'alarm shift; exec @ARGV' 300 gdb -q "$EXE" "$CORE" < gdb_cmds.txt || echo "GDB timed out or failed"
                else
                    echo "Core file or executable not found."
                    ls -R
                fi
                exit $EXIT_CODE
            fi
            touch ../../../UNIT_TEST_SUCCESS

      - name: Check Retry
        id: CheckRetry
        run: |
          if [ ! -f "UNIT_TEST_STARTED" ]; then
            echo "retry=true" >> $GITHUB_OUTPUT
          elif [ ! -f "UNIT_TEST_SUCCESS" ]; then
            echo "::error::Test script execution failed! (Not retrying)"
            exit 1
          fi
      - name: Cleanup Before Retry
        if: steps.CheckRetry.outputs.retry == 'true'
        run: |
          set +e 
          DOMAINS="$(sudo virsh list --all --name 2>/dev/null | grep -v "^$" || true)"
          if [ -z "$DOMAINS" ]; then
          echo "No lingering domains found (virsh may be unavailable or no domains exist)."
          else
          echo "Found domains: $DOMAINS"
          for DOMAIN in $DOMAINS; do
            echo "Processing domain: $DOMAIN"
            sudo virsh destroy "$DOMAIN" 2>/dev/null || echo "virsh destroy failed for $DOMAIN (ignored)"
            sudo virsh undefine "$DOMAIN" --nvram 2>/dev/null \
              || sudo virsh undefine "$DOMAIN" 2>/dev/null \
              || echo "virsh undefine failed for $DOMAIN (ignored)"
          done
          fi

          echo "--- Removing potentially corrupted VM images ---"
          find . -name "*.qcow2" -delete 2>/dev/null || echo "local qcow2 cleanup failed (ignored)"
          sudo find /home/runner/work/_actions/vmactions -name "*.qcow2" -delete 2>/dev/null || echo "vmactions qcow2 cleanup failed (ignored)"
          sudo rm -f /var/lib/libvirt/dnsmasq/*.leases 2>/dev/null || echo "dnsmasq leases cleanup failed (ignored)"
          sleep 5
          echo "Cleanup complete."

      - name: Run in Solaris (Attempt 2)
        if: steps.CheckRetry.outputs.retry == 'true'
        uses: vmactions/solaris-vm@v1
        with:
          usesh: true
          mem: 8192
          prepare: |
            for i in 1 2 3 4 5; do
              (
                pkg publisher && \
                pkg install -v --accept \
                  developer/build/cmake \
                  developer/build/gnu-make \
                  developer/debug/gdb \
                  developer/gcc-14 \
                  shell/bash
              ) && exit 0
              echo "Install failed, retrying in 60s... ($i/5)"
              sleep 60
            done
            exit 1
          run: |
            ulimit -c unlimited
            set -e -x
            cd build/test/unix_like  
            chmod +x *.sh
            ls -l
            
            set +e
            ./run_test_gcc.sh ${{ matrix.cpp_ver }} 
            EXIT_CODE=$?
            set -e

            if [ $EXIT_CODE -ne 0 ]; then
                echo "Test failed with exit code $EXIT_CODE"
                echo "Waiting 30s for core dump to finish writing..."
                sleep 30
                CORE=$(find . -name core -type f | head -n 1)
                EXE=$(find . -name BqLogUnitTest -type f | head -n 1)
                if [ -n "$CORE" ] && [ -n "$EXE" ]; then
                    echo "=== GDB BACKTRACE ==="
                    echo "set pagination off" > gdb_cmds.txt
                    echo "thread apply all bt full" >> gdb_cmds.txt
                    echo "quit" >> gdb_cmds.txt
                    # Use perl for timeout (300s = 5min) to avoid CI hang
                    perl -e 'alarm shift; exec @ARGV' 300 gdb -q "$EXE" "$CORE" < gdb_cmds.txt || echo "GDB timed out or failed"
                else
                    echo "Core file or executable not found."
                    ls -R
                fi
                exit $EXIT_CODE
            fi 

  #Unix-OmnisOS
  omnisOS_x86_64_GCC:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        cpp_ver: [ 11, 14, 17, 20, 23 ]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Free Disk Space (Ubuntu)
        uses: jlumbroso/free-disk-space@v1.3.1
        with:
          tool-cache: false
          android: true
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: true
          swap-storage: true

      - name: Run in OmnisOS（Attempt 1）
        uses: vmactions/omnios-vm@v1
        continue-on-error: true
        with:
          usesh: true
          mem: 8192
          prepare: |
            for i in 1 2 3 4 5; do
              (
                set -e
                pkg refresh --full
                if ! pkg publisher | grep -q '^extra\.omnios'; then
                  REL="$(uname -v | sed -n 's/.*\(r[0-9][0-9]*\).*/\1/p')"
                  [ -n "$REL" ] || REL="r151054"
                  pkg set-publisher -g "https://pkg.omnios.org/${REL}/extra" extra.omnios || true
                  pkg refresh --full
                fi
                pkg install -v --accept shell/bash developer/build/gnu-make || true
                pkg install -v --accept ooce/developer/cmake
                pkg install -v --accept developer/gcc13
              ) && exit 0
              echo "Prepare failed, retrying in 60s... ($i/5)"
              sleep 60
            done
            exit 1
          run: |
            touch UNIT_TEST_STARTED
            set -e -x
            cd build/test/unix_like  
            chmod +x *.sh
            ls -l
            ./run_test_gcc.sh ${{ matrix.cpp_ver }} 
            touch ../../../UNIT_TEST_SUCCESS

      - name: Check Retry
        id: CheckRetry
        run: |
          if [ ! -f "UNIT_TEST_STARTED" ]; then
            echo "retry=true" >> $GITHUB_OUTPUT
          elif [ ! -f "UNIT_TEST_SUCCESS" ]; then
            echo "::error::Test script execution failed! (Not retrying)"
            exit 1
          fi

      - name: Cleanup Before Retry
        if: steps.CheckRetry.outputs.retry == 'true'
        run: |
          set +e 
          DOMAINS="$(sudo virsh list --all --name 2>/dev/null | grep -v "^$" || true)"
          if [ -z "$DOMAINS" ]; then
            echo "No lingering domains found (virsh may be unavailable or no domains exist)."
          else
            echo "Found domains: $DOMAINS"
            for DOMAIN in $DOMAINS; do
              echo "Processing domain: $DOMAIN"
              sudo virsh destroy "$DOMAIN" 2>/dev/null || echo "virsh destroy failed for $DOMAIN (ignored)"
              sudo virsh undefine "$DOMAIN" --nvram 2>/dev/null \
                || sudo virsh undefine "$DOMAIN" 2>/dev/null \
                || echo "virsh undefine failed for $DOMAIN (ignored)"
            done
          fi

          echo "--- Removing potentially corrupted VM images ---"
          find . -name "*.qcow2" -delete 2>/dev/null || echo "local qcow2 cleanup failed (ignored)"
          sudo find /home/runner/work/_actions/vmactions -name "*.qcow2" -delete 2>/dev/null || echo "vmactions qcow2 cleanup failed (ignored)"
          sudo rm -f /var/lib/libvirt/dnsmasq/*.leases 2>/dev/null || echo "dnsmasq leases cleanup failed (ignored)"
          sleep 5
          echo "Cleanup complete."

      - name: Run in OmnisOS (Attempt 2)
        if: steps.CheckRetry.outputs.retry == 'true'
        uses: vmactions/omnios-vm@v1
        with:
          usesh: true
          mem: 8192
          prepare: |
            for i in 1 2 3 4 5; do
              (
                set -e
                pkg refresh --full
                if ! pkg publisher | grep -q '^extra\.omnios'; then
                  REL="$(uname -v | sed -n 's/.*\(r[0-9][0-9]*\).*/\1/p')"
                  [ -n "$REL" ] || REL="r151054"
                  pkg set-publisher -g "https://pkg.omnios.org/${REL}/extra" extra.omnios || true
                  pkg refresh --full
                fi
                pkg install -v --accept shell/bash developer/build/gnu-make || true
                pkg install -v --accept ooce/developer/cmake
                pkg install -v --accept developer/gcc13
              ) && exit 0
              echo "Prepare failed, retrying in 60s... ($i/5)"
              sleep 60
            done
            exit 1
          run: |
            touch UNIT_TEST_STARTED
            set -e -x
            cd build/test/unix_like  
            chmod +x *.sh
            ls -l
            ./run_test_gcc.sh ${{ matrix.cpp_ver }} 
            touch ../../../UNIT_TEST_SUCCESS

  #Unix-DragonFlyBSD
  dragonflyBSD_x86_64:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        cc: [ clang, gcc ]
        cpp_ver: [ 11, 14, 17, 20, 23 ]
        exclude:
          - cc: gcc
            cpp_ver: 23
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Free Disk Space (Ubuntu)
        uses: jlumbroso/free-disk-space@v1.3.1
        with:
          tool-cache: false
          android: true
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: true
          swap-storage: true

      - name: Run in DragonFlyBSD  (Attempt 1)
        continue-on-error: true
        uses: vmactions/dragonflybsd-vm@v1
        with:
          usesh: true
          mem: 8192
          prepare: |
            for i in 1 2 3 4 5; do
              pkg install -y cmake bash gmake gdb openjdk11 gcc llvm && exit 0
              echo "Install failed, retrying in 60s... ($i/5)"
              sleep 60
            done
            exit 1
          run: |
            touch UNIT_TEST_STARTED
            set -e -x
            ulimit -c unlimited || true
            sysctl kern.coredump=1 || true

            cd build/test/unix_like  
            chmod +x *.sh
            ls -l
            
            set +e
            ./run_test_${{ matrix.cc }}.sh ${{ matrix.cpp_ver }}  
            EXIT_CODE=$?
            set -e

            if [ $EXIT_CODE -ne 0 ]; then
              echo "Test failed with exit code $EXIT_CODE"
              # Look for core files. DragonflyBSD often names them <progname>.core
              CORE_FILE="$(find . -maxdepth 5 -type f \( -name 'core' -o -name '*.core' \) 2>/dev/null | head -n1)"
              
              EXE=""
              for cand in ./BqLogUnitTest ./CMakeFiles/BqLogUnitTest $(find . -maxdepth 5 -type f -name 'BqLogUnitTest' 2>/dev/null | head -n1); do
                if [ -n "$cand" ] && [ -x "$cand" ]; then EXE="$cand"; break; fi
              done

              echo "exe: ${EXE:-<not found>}"
              echo "core: ${CORE_FILE:-<not found>}"

              if [ -n "$CORE_FILE" ] && [ -n "$EXE" ]; then
                echo "=== GDB core backtrace (DragonflyBSD) ==="
                gdb --batch -q \
                  -ex "set pagination off" \
                  -ex "info threads" \
                  -ex "thread apply all bt full" \
                  -ex "quit" \
                  "$EXE" "$CORE_FILE" || echo "gdb analysis failed"
              else
                echo "Core file or executable not found. Listing all files:"
                ls -R || true
              fi
              exit $EXIT_CODE
            fi
            touch ../../../UNIT_TEST_SUCCESS

      - name: Check Retry
        id: CheckRetry
        run: |
          if [ ! -f "UNIT_TEST_STARTED" ]; then
            echo "retry=true" >> $GITHUB_OUTPUT
          elif [ ! -f "UNIT_TEST_SUCCESS" ]; then
            echo "::error::Test script execution failed! (Not retrying)"
            exit 1
          fi
      - name: Cleanup Before Retry
        if: steps.CheckRetry.outputs.retry == 'true'
        run: |
          set +e 
          DOMAINS="$(sudo virsh list --all --name 2>/dev/null | grep -v "^$" || true)"
          if [ -z "$DOMAINS" ]; then
            echo "No lingering domains found (virsh may be unavailable or no domains exist)."
          else
            echo "Found domains: $DOMAINS"
            for DOMAIN in $DOMAINS; do
              echo "Processing domain: $DOMAIN"
              sudo virsh destroy "$DOMAIN" 2>/dev/null || echo "virsh destroy failed for $DOMAIN (ignored)"
              sudo virsh undefine "$DOMAIN" --nvram 2>/dev/null \
                || sudo virsh undefine "$DOMAIN" 2>/dev/null \
                || echo "virsh undefine failed for $DOMAIN (ignored)"
            done
          fi

          echo "--- Removing potentially corrupted VM images ---"
          find . -name "*.qcow2" -delete 2>/dev/null || echo "local qcow2 cleanup failed (ignored)"
          sudo find /home/runner/work/_actions/vmactions -name "*.qcow2" -delete 2>/dev/null || echo "vmactions qcow2 cleanup failed (ignored)"
          sudo rm -f /var/lib/libvirt/dnsmasq/*.leases 2>/dev/null || echo "dnsmasq leases cleanup failed (ignored)"
          sleep 5
          echo "Cleanup complete."

      - name: Run in DragonFlyBSD  (Attempt 2)
        if: steps.CheckRetry.outputs.retry == 'true'
        uses: vmactions/dragonflybsd-vm@v1
        with:
          usesh: true
          mem: 8192
          prepare: |
            for i in 1 2 3 4 5; do
              pkg install -y cmake bash gmake gdb openjdk11 gcc llvm && exit 0
              echo "Install failed, retrying in 60s... ($i/5)"
              sleep 60
            done
            exit 1
          run: |
            touch UNIT_TEST_STARTED
            set -e -x
            ulimit -c unlimited || true
            sysctl kern.coredump=1 || true

            cd build/test/unix_like  
            chmod +x *.sh
            ls -l
            
            set +e
            ./run_test_${{ matrix.cc }}.sh ${{ matrix.cpp_ver }}  
            EXIT_CODE=$?
            set -e

            if [ $EXIT_CODE -ne 0 ]; then
              echo "Test failed with exit code $EXIT_CODE"
              # Look for core files. DragonflyBSD often names them <progname>.core
              CORE_FILE="$(find . -maxdepth 5 -type f \( -name 'core' -o -name '*.core' \) 2>/dev/null | head -n1)"
              
              EXE=""
              for cand in ./BqLogUnitTest ./CMakeFiles/BqLogUnitTest $(find . -maxdepth 5 -type f -name 'BqLogUnitTest' 2>/dev/null | head -n1); do
                if [ -n "$cand" ] && [ -x "$cand" ]; then EXE="$cand"; break; fi
              done

              echo "exe: ${EXE:-<not found>}"
              echo "core: ${CORE_FILE:-<not found>}"

              if [ -n "$CORE_FILE" ] && [ -n "$EXE" ]; then
                echo "=== GDB core backtrace (DragonflyBSD) ==="
                gdb --batch -q \
                  -ex "set pagination off" \
                  -ex "info threads" \
                  -ex "thread apply all bt full" \
                  -ex "quit" \
                  "$EXE" "$CORE_FILE" || echo "gdb analysis failed"
              else
                echo "Core file or executable not found. Listing all files:"
                ls -R || true
              fi
              exit $EXIT_CODE
            fi
            touch ../../../UNIT_TEST_SUCCESS

  #Unix-OpenBSD
  openBSD_X86_64_Clang:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        cpp_ver: [ 11, 14, 17, 20, 23 ]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Free Disk Space (Ubuntu)
        uses: jlumbroso/free-disk-space@v1.3.1
        with:
          tool-cache: false
          android: true
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: true
          swap-storage: true

      - name: Run in OpenBSD (Attempt 1)
        continue-on-error: true
        uses: vmactions/openbsd-vm@v1
        with:
          usesh: true
          mem: 8192
          prepare: |
            set -x
            for i in 1 2 3 4 5; do
              (
                export PKG_PATH="http://cdn.openbsd.org/pub/OpenBSD/$(uname -r)/packages/$(arch -s)/" && \
                pkg_add -v -I cmake bash gdb
              ) && {
                echo "PATH=$PATH"
                pkg_info | grep gdb
                ls -l /usr/local/bin/gdb* /usr/bin/gdb*
                exit 0
              }
              echo "Install failed, retrying in 60s... ($i/5)"
              sleep 60
            done
            exit 1

          run: |
            touch UNIT_TEST_STARTED
            set -e -x
            ulimit -c unlimited || true
            sysctl kern.coredump=1 || true
            sysctl kern.corefile=core.%p 2>/dev/null || sysctl kern.corefile=core || true

            cd build/test/unix_like
            chmod +x *.sh

            GDB_CMD=""
            if [ -x "/usr/local/bin/gdb" ]; then
              GDB_CMD="/usr/local/bin/gdb"
            elif [ -x "/usr/local/bin/egdb" ]; then
              GDB_CMD="/usr/local/bin/egdb"
            elif [ -x "/usr/bin/gdb" ]; then
              GDB_CMD="/usr/bin/gdb"
            fi

            if [ -n "$GDB_CMD" ]; then
              echo "Found GDB at: $GDB_CMD"
              if ! $GDB_CMD --version | grep "GNU gdb"; then
                echo "!!! Command '$GDB_CMD' is not a valid GNU gdb. Aborting."
                exit 1
              fi
            else
              echo "!!! GNU gdb not found. Aborting."
              exit 1
            fi

            set +e
            ulimit -n
            ulimit -Hn
            ulimit -n 4096
            ./run_test_clang.sh ${{ matrix.cpp_ver }}
            EXIT_CODE=$?
            set -e

            if [ $EXIT_CODE -ne 0 ]; then
              echo "Test failed with exit $EXIT_CODE. Searching for core..."
              CORE_FILE="$(find . -maxdepth 5 -type f \( -name 'core' -o -name 'core.*' -o -name '*.core' \) 2>/dev/null | head -n1)"

              EXE=""
              for cand in ./BqLogUnitTest ./CMakeFiles/BqLogUnitTest $(find . -maxdepth 5 -type f -name 'BqLogUnitTest' 2>/dev/null | head -n1); do
                if [ -n "$cand" ] && [ -x "$cand" ]; then EXE="$cand"; break; fi
              done

              echo "exe: ${EXE:-<not found>}"
              echo "core: ${CORE_FILE:-<not found>}"

              if [ -n "$CORE_FILE" ] && [ -n "$EXE" ]; then
                echo "=== GDB core backtrace ==="
                $GDB_CMD --batch -q \
                  -ex "set pagination off" \
                  -ex "info threads" \
                  -ex "thread apply all bt full" \
                  -ex "quit" \
                  "$EXE" "$CORE_FILE" || echo "gdb core analysis failed"
              elif [ -n "$EXE" ]; then
                echo "Core not found; run once under gdb for live backtrace"
                $GDB_CMD --batch -q \
                  -ex "run" \
                  -ex "info threads" \
                  -ex "thread apply all bt full" \
                  -ex "quit" \
                  "$EXE" || true
              fi
              exit $EXIT_CODE
            fi
            touch ../../../UNIT_TEST_SUCCESS

      - name: Check Retry
        id: CheckRetry
        run: |
          if [ ! -f "UNIT_TEST_STARTED" ]; then
            echo "retry=true" >> $GITHUB_OUTPUT
          elif [ ! -f "UNIT_TEST_SUCCESS" ]; then
            echo "::error::Test script execution failed! (Not retrying)"
            exit 1
          fi
      - name: Cleanup Before Retry
        if: steps.CheckRetry.outputs.retry == 'true'
        run: |
          set +e 
          DOMAINS="$(sudo virsh list --all --name 2>/dev/null | grep -v "^$" || true)"
          if [ -z "$DOMAINS" ]; then
            echo "No lingering domains found (virsh may be unavailable or no domains exist)."
          else
            echo "Found domains: $DOMAINS"
            for DOMAIN in $DOMAINS; do
              echo "Processing domain: $DOMAIN"
              sudo virsh destroy "$DOMAIN" 2>/dev/null || echo "virsh destroy failed for $DOMAIN (ignored)"
              sudo virsh undefine "$DOMAIN" --nvram 2>/dev/null \
                || sudo virsh undefine "$DOMAIN" 2>/dev/null \
                || echo "virsh undefine failed for $DOMAIN (ignored)"
            done
          fi

          echo "--- Removing potentially corrupted VM images ---"
          find . -name "*.qcow2" -delete 2>/dev/null || echo "local qcow2 cleanup failed (ignored)"
          sudo find /home/runner/work/_actions/vmactions -name "*.qcow2" -delete 2>/dev/null || echo "vmactions qcow2 cleanup failed (ignored)"
          sudo rm -f /var/lib/libvirt/dnsmasq/*.leases 2>/dev/null || echo "dnsmasq leases cleanup failed (ignored)"
          sleep 5
          echo "Cleanup complete."

      - name: Run in OpenBSD (Attempt 2)
        if: steps.CheckRetry.outputs.retry == 'true'
        uses: vmactions/openbsd-vm@v1
        with:
          usesh: true
          mem: 8192
          prepare: |
            set -x
            for i in 1 2 3 4 5; do
              (
                export PKG_PATH="http://cdn.openbsd.org/pub/OpenBSD/$(uname -r)/packages/$(arch -s)/" && \
                pkg_add -v -I cmake bash gdb
              ) && {
                echo "PATH=$PATH"
                pkg_info | grep gdb
                ls -l /usr/local/bin/gdb* /usr/bin/gdb*
                exit 0
              }
              echo "Install failed, retrying in 60s... ($i/5)"
              sleep 60
            done
            exit 1

          run: |
            touch UNIT_TEST_STARTED
            set -e -x
            ulimit -c unlimited || true
            sysctl kern.coredump=1 || true
            sysctl kern.corefile=core.%p 2>/dev/null || sysctl kern.corefile=core || true

            cd build/test/unix_like
            chmod +x *.sh

            GDB_CMD=""
            if [ -x "/usr/local/bin/gdb" ]; then
              GDB_CMD="/usr/local/bin/gdb"
            elif [ -x "/usr/local/bin/egdb" ]; then
              GDB_CMD="/usr/local/bin/egdb"
            elif [ -x "/usr/bin/gdb" ]; then
              GDB_CMD="/usr/bin/gdb"
            fi

            if [ -n "$GDB_CMD" ]; then
              echo "Found GDB at: $GDB_CMD"
              if ! $GDB_CMD --version | grep "GNU gdb"; then
                echo "!!! Command '$GDB_CMD' is not a valid GNU gdb. Aborting."
                exit 1
              fi
            else
              echo "!!! GNU gdb not found. Aborting."
              exit 1
            fi

            set +e
            ulimit -n
            ulimit -Hn
            ulimit -n 4096
            ./run_test_clang.sh ${{ matrix.cpp_ver }}
            EXIT_CODE=$?
            set -e

            if [ $EXIT_CODE -ne 0 ]; then
              echo "Test failed with exit $EXIT_CODE. Searching for core..."
              CORE_FILE="$(find . -maxdepth 5 -type f \( -name 'core' -o -name 'core.*' -o -name '*.core' \) 2>/dev/null | head -n1)"

              EXE=""
              for cand in ./BqLogUnitTest ./CMakeFiles/BqLogUnitTest $(find . -maxdepth 5 -type f -name 'BqLogUnitTest' 2>/dev/null | head -n1); do
                if [ -n "$cand" ] && [ -x "$cand" ]; then EXE="$cand"; break; fi
              done

              echo "exe: ${EXE:-<not found>}"
              echo "core: ${CORE_FILE:-<not found>}"

              if [ -n "$CORE_FILE" ] && [ -n "$EXE" ]; then
                echo "=== GDB core backtrace ==="
                $GDB_CMD --batch -q \
                  -ex "set pagination off" \
                  -ex "info threads" \
                  -ex "thread apply all bt full" \
                  -ex "quit" \
                  "$EXE" "$CORE_FILE" || echo "gdb core analysis failed"
              elif [ -n "$EXE" ]; then
                echo "Core not found; run once under gdb for live backtrace"
                $GDB_CMD --batch -q \
                  -ex "run" \
                  -ex "info threads" \
                  -ex "thread apply all bt full" \
                  -ex "quit" \
                  "$EXE" || true
              fi
              exit $EXIT_CODE
            fi
            touch ../../../UNIT_TEST_SUCCESS

  openBSD_arm64_Clang:
    if: ${{ github.event.inputs.run_arm_tests == true || github.event.inputs.run_arm_tests == 'true'}}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        cpp_ver: [ 11, 14, 17, 20, 23 ]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Free Disk Space (Ubuntu)
        uses: jlumbroso/free-disk-space@v1.3.1
        with:
          tool-cache: false
          android: true
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: true
          swap-storage: true

      - name: Run in OpenBSD (Attempt 1)
        continue-on-error: true
        uses: vmactions/openbsd-vm@v1
        with:
          arch: aarch64
          usesh: true
          mem: 8192
          prepare: |
            for i in 1 2 3 4 5; do
              pkg_add cmake bash && exit 0
              echo "Install failed, retrying in 60s... ($i/5)"
              sleep 60
            done
            exit 1
          run: |
            touch UNIT_TEST_STARTED
            set -e -x
            cd build/test/unix_like  
            chmod +x *.sh
            ls -l
            ulimit -n
            ulimit -Hn
            ulimit -n 4096
            export BQ_LOW_PERFORMANCE_TESTS=true
            ./run_test_clang.sh ${{ matrix.cpp_ver }}
            touch ../../../UNIT_TEST_SUCCESS

      - name: Check Retry
        id: CheckRetry
        run: |
          if [ ! -f "UNIT_TEST_STARTED" ]; then
            echo "retry=true" >> $GITHUB_OUTPUT
          elif [ ! -f "UNIT_TEST_SUCCESS" ]; then
            echo "::error::Test script execution failed! (Not retrying)"
            exit 1
          fi
      - name: Cleanup Before Retry
        if: steps.CheckRetry.outputs.retry == 'true'
        run: |
          set +e 
          DOMAINS="$(sudo virsh list --all --name 2>/dev/null | grep -v "^$" || true)"
          if [ -z "$DOMAINS" ]; then
            echo "No lingering domains found (virsh may be unavailable or no domains exist)."
          else
            echo "Found domains: $DOMAINS"
            for DOMAIN in $DOMAINS; do
              echo "Processing domain: $DOMAIN"
              sudo virsh destroy "$DOMAIN" 2>/dev/null || echo "virsh destroy failed for $DOMAIN (ignored)"
              sudo virsh undefine "$DOMAIN" --nvram 2>/dev/null \
                || sudo virsh undefine "$DOMAIN" 2>/dev/null \
                || echo "virsh undefine failed for $DOMAIN (ignored)"
            done
          fi

          echo "--- Removing potentially corrupted VM images ---"
          find . -name "*.qcow2" -delete 2>/dev/null || echo "local qcow2 cleanup failed (ignored)"
          sudo find /home/runner/work/_actions/vmactions -name "*.qcow2" -delete 2>/dev/null || echo "vmactions qcow2 cleanup failed (ignored)"
          sudo rm -f /var/lib/libvirt/dnsmasq/*.leases 2>/dev/null || echo "dnsmasq leases cleanup failed (ignored)"
          sleep 5
          echo "Cleanup complete."

      - name: Run in OpenBSD (Attempt 2)
        if: steps.CheckRetry.outputs.retry == 'true'
        uses: vmactions/openbsd-vm@v1
        with:
          arch: aarch64
          usesh: true
          mem: 8192
          prepare: |
            for i in 1 2 3 4 5; do
              pkg_add cmake bash && exit 0
              echo "Install failed, retrying in 60s... ($i/5)"
              sleep 60
            done
            exit 1
          run: |
            touch UNIT_TEST_STARTED
            set -e -x
            cd build/test/unix_like  
            chmod +x *.sh
            ls -l
            ulimit -n
            ulimit -Hn
            ulimit -n 4096
            export BQ_LOW_PERFORMANCE_TESTS=true
            ./run_test_clang.sh ${{ matrix.cpp_ver }}
            touch ../../../UNIT_TEST_SUCCESS

  #NetBSD
  netBSD_x86_64:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        cc: [ clang, gcc ]
        cpp_ver: [ 11, 14, 17, 20, 23 ]
        exclude:
          - cc: gcc
            cpp_ver: 23
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Free Disk Space (Ubuntu)
        uses: jlumbroso/free-disk-space@v1.3.1
        with:
          tool-cache: false
          android: true
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: true
          swap-storage: true

      - name: Run in NetBSD (Attempt 1)
        continue-on-error: true
        uses: vmactions/netbsd-vm@v1
        with:
          usesh: true
          mem: 8192
          release: "10.1"
          prepare: |
            export PATH="/usr/sbin:/usr/bin:/usr/pkg/sbin:/usr/pkg/bin:$PATH"
            for i in 1 2 3 4 5; do
              (
                set -e
                /usr/sbin/pkg_add -v pkgin || true
                pkgin -y update
                pkgin -y install cmake gmake bash gdb
                pkgin -y install clang
                pkgin -y install gcc12 || pkgin -y install gcc13 || pkgin -y install gcc10
              ) && exit 0
            
              echo "Install failed, retrying in 60s... ($i/5)"
              sleep 60
            done
            exit 1
          run: |
            touch UNIT_TEST_STARTED
            set -e -x
            cd build/test/unix_like  
            chmod +x *.sh
            ls -l
            ulimit -n
            ulimit -Hn
            ulimit -n 4096
            ./run_test_${{ matrix.cc }}.sh ${{ matrix.cpp_ver }}
            touch ../../../UNIT_TEST_SUCCESS

      - name: Check Retry
        id: CheckRetry
        run: |
          if [ ! -f "UNIT_TEST_STARTED" ]; then
            echo "retry=true" >> $GITHUB_OUTPUT
          elif [ ! -f "UNIT_TEST_SUCCESS" ]; then
            echo "::error::Test script execution failed! (Not retrying)"
            exit 1
          fi
      - name: Cleanup Before Retry
        if: steps.CheckRetry.outputs.retry == 'true'
        run: |
          set +e 
          DOMAINS="$(sudo virsh list --all --name 2>/dev/null | grep -v "^$" || true)"
          if [ -z "$DOMAINS" ]; then
            echo "No lingering domains found (virsh may be unavailable or no domains exist)."
          else
            echo "Found domains: $DOMAINS"
            for DOMAIN in $DOMAINS; do
              echo "Processing domain: $DOMAIN"
              sudo virsh destroy "$DOMAIN" 2>/dev/null || echo "virsh destroy failed for $DOMAIN (ignored)"
              sudo virsh undefine "$DOMAIN" --nvram 2>/dev/null \
                || sudo virsh undefine "$DOMAIN" 2>/dev/null \
                || echo "virsh undefine failed for $DOMAIN (ignored)"
            done
          fi

          echo "--- Removing potentially corrupted VM images ---"
          find . -name "*.qcow2" -delete 2>/dev/null || echo "local qcow2 cleanup failed (ignored)"
          sudo find /home/runner/work/_actions/vmactions -name "*.qcow2" -delete 2>/dev/null || echo "vmactions qcow2 cleanup failed (ignored)"
          sudo rm -f /var/lib/libvirt/dnsmasq/*.leases 2>/dev/null || echo "dnsmasq leases cleanup failed (ignored)"
          sleep 5
          echo "Cleanup complete."

      - name: Run in NetBSD (Attempt 2)
        if: steps.CheckRetry.outputs.retry == 'true'
        uses: vmactions/netbsd-vm@v1
        with:
          usesh: true
          mem: 8192
          release: "10.1"
          prepare: |
            export PATH="/usr/sbin:/usr/bin:/usr/pkg/sbin:/usr/pkg/bin:$PATH"
            for i in 1 2 3 4 5; do
              (
                set -e
                /usr/sbin/pkg_add -v pkgin || true
                pkgin -y update
                pkgin -y install cmake gmake bash gdb
                pkgin -y install clang
                pkgin -y install gcc12 || pkgin -y install gcc13 || pkgin -y install gcc10
              ) && exit 0
            
              echo "Install failed, retrying in 60s... ($i/5)"
              sleep 60
            done
            exit 1
          run: |
            touch UNIT_TEST_STARTED
            set -e -x
            cd build/test/unix_like  
            chmod +x *.sh
            ls -l
            ulimit -n
            ulimit -Hn
            ulimit -n 4096
            ./run_test_${{ matrix.cc }}.sh ${{ matrix.cpp_ver }}
            touch ../../../UNIT_TEST_SUCCESS

  netBSD_arm64_cpp17:
    if: ${{ github.event.inputs.run_arm_tests == true || github.event.inputs.run_arm_tests == 'true' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        cc: [ clang, gcc ]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Free Disk Space (Ubuntu)
        uses: jlumbroso/free-disk-space@v1.3.1
        with:
          tool-cache: false
          android: true
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: true
          swap-storage: true

      - name: Run in NetBSD (Attempt 1)
        continue-on-error: true
        uses: vmactions/netbsd-vm@v1
        with:
          arch: aarch64
          usesh: true
          mem: 8192
          release: "10.1"
          prepare: |
            export PATH="/usr/sbin:/usr/bin:/usr/pkg/sbin:/usr/pkg/bin:$PATH"
            for i in 1 2 3 4 5; do
              (
                set -e
                /usr/sbin/pkg_add -v pkgin || true
                pkgin -y update
                pkgin -y install cmake gmake bash gdb
                pkgin -y install clang
                pkgin -y install gcc12 || pkgin -y install gcc13 || pkgin -y install gcc10
              ) && exit 0

              echo "Install failed, retrying in 60s... ($i/5)"
              sleep 60
            done
            exit 1
          run: |
            touch UNIT_TEST_STARTED
            set -e -x
            cd build/test/unix_like  
            chmod +x *.sh
            ls -l
            ulimit -n
            ulimit -Hn
            ulimit -n 4096
            export BQ_LOW_PERFORMANCE_TESTS=true
            ./run_test_${{ matrix.cc }}.sh 17
            touch ../../../UNIT_TEST_SUCCESS

      - name: Check Retry
        id: CheckRetry
        run: |
          if [ ! -f "UNIT_TEST_STARTED" ]; then
            echo "retry=true" >> $GITHUB_OUTPUT
          elif [ ! -f "UNIT_TEST_SUCCESS" ]; then
            echo "::error::Test script execution failed! (Not retrying)"
            exit 1
          fi
      - name: Cleanup Before Retry
        if: steps.CheckRetry.outputs.retry == 'true'
        run: |
          set +e 
          DOMAINS="$(sudo virsh list --all --name 2>/dev/null | grep -v "^$" || true)"
          if [ -z "$DOMAINS" ]; then
            echo "No lingering domains found (virsh may be unavailable or no domains exist)."
          else
            echo "Found domains: $DOMAINS"
            for DOMAIN in $DOMAINS; do
              echo "Processing domain: $DOMAIN"
              sudo virsh destroy "$DOMAIN" 2>/dev/null || echo "virsh destroy failed for $DOMAIN (ignored)"
              sudo virsh undefine "$DOMAIN" --nvram 2>/dev/null \
                || sudo virsh undefine "$DOMAIN" 2>/dev/null \
                || echo "virsh undefine failed for $DOMAIN (ignored)"
            done
          fi

          echo "--- Removing potentially corrupted VM images ---"
          find . -name "*.qcow2" -delete 2>/dev/null || echo "local qcow2 cleanup failed (ignored)"
          sudo find /home/runner/work/_actions/vmactions -name "*.qcow2" -delete 2>/dev/null || echo "vmactions qcow2 cleanup failed (ignored)"
          sudo rm -f /var/lib/libvirt/dnsmasq/*.leases 2>/dev/null || echo "dnsmasq leases cleanup failed (ignored)"
          sleep 5
          echo "Cleanup complete."

      - name: Run in NetBSD (Attempt 2)
        if: steps.CheckRetry.outputs.retry == 'true'
        uses: vmactions/netbsd-vm@v1
        with:
          arch: aarch64
          usesh: true
          mem: 8192
          release: "10.1"
          prepare: |
            export PATH="/usr/sbin:/usr/bin:/usr/pkg/sbin:/usr/pkg/bin:$PATH"
            for i in 1 2 3 4 5; do
              (
                set -e
                /usr/sbin/pkg_add -v pkgin || true
                pkgin -y update
                pkgin -y install cmake gmake bash gdb
                pkgin -y install clang
                pkgin -y install gcc12 || pkgin -y install gcc13 || pkgin -y install gcc10
              ) && exit 0

              echo "Install failed, retrying in 60s... ($i/5)"
              sleep 60
            done
            exit 1
          run: |
            touch UNIT_TEST_STARTED
            set -e -x
            cd build/test/unix_like  
            chmod +x *.sh
            ls -l
            ulimit -n
            ulimit -Hn
            ulimit -n 4096
            export BQ_LOW_PERFORMANCE_TESTS=true
            ./run_test_${{ matrix.cc }}.sh 17
            touch ../../../UNIT_TEST_SUCCESS


  #Android Test
  android:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - abi: x86
            api-level: 21
          - abi: x86_64
            api-level: 33

    steps:
      - uses: actions/checkout@v4

      - name: Free Disk Space (Ubuntu)
        uses: jlumbroso/free-disk-space@v1.3.1
        with:
          tool-cache: false
          android: false
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: true
          swap-storage: true

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'adopt'

      - id: setup-android
        uses: android-actions/setup-android@v3

      - name: Enable KVM
        run: |
          echo 'KERNEL=="kvm", GROUP="kvm", MODE="0666", OPTIONS+="static_node=kvm"' | sudo tee /etc/udev/rules.d/99-kvm4all.rules
          sudo udevadm control --reload-rules
          sudo udevadm trigger --name-match=kvm
          ls -l /dev/kvm || true

      - id: setup-ndk
        uses: nttld/setup-ndk@v1
        with:
          ndk-version: r28c
          local-cache: false

      - name: Build Debug
        env:
          ANDROID_ABI: ${{ matrix.abi }}
          ANDROID_PLATFORM: ${{ matrix.api-level }}
          ANDROID_NDK: ${{ steps.setup-ndk.outputs.ndk-path }}
        run: |
          set -e
          mkdir -p build/test/android/${ANDROID_ABI}/debug
          cd build/test/android/${ANDROID_ABI}/debug
          cmake ../../../../../test/cpp \
            -G "Unix Makefiles" \
            -DANDROID_ABI=${ANDROID_ABI} \
            -DANDROID_PLATFORM=${ANDROID_PLATFORM} \
            -DANDROID_NDK=${ANDROID_NDK} \
            -DCMAKE_BUILD_TYPE=Debug \
            -DCMAKE_TOOLCHAIN_FILE=${ANDROID_NDK}/build/cmake/android.toolchain.cmake \
            -DTARGET_PLATFORM:STRING=android
          cmake --build . -- -j10

      - name: Build RelWithDebInfo
        env:
          ANDROID_ABI: ${{ matrix.abi }}
          ANDROID_PLATFORM: ${{ matrix.api-level }}
          ANDROID_NDK: ${{ steps.setup-ndk.outputs.ndk-path }}
        run: |
          set -e
          mkdir -p build/test/android/${ANDROID_ABI}/relwithdebinfo
          cd build/test/android/${ANDROID_ABI}/relwithdebinfo
          cmake ../../../../../test/cpp \
            -G "Unix Makefiles" \
            -DANDROID_ABI=${ANDROID_ABI} \
            -DANDROID_PLATFORM=${ANDROID_PLATFORM} \
            -DANDROID_NDK=${ANDROID_NDK} \
            -DCMAKE_BUILD_TYPE=RelWithDebInfo \
            -DCMAKE_TOOLCHAIN_FILE=${ANDROID_NDK}/build/cmake/android.toolchain.cmake \
            -DTARGET_PLATFORM:STRING=android
          cmake --build . -- -j10

      - name: Locate artifacts
        id: locate
        env:
          ABI: ${{ matrix.abi }}
        run: |
          set -e
          DBG="build/test/android/${ABI}/debug/BqLogUnitTest"
          REL="build/test/android/${ABI}/relwithdebinfo/BqLogUnitTest"
          [ -f "$DBG" ] || DBG="$(find build/test/android/${ABI}/debug -type f -name BqLogUnitTest | head -n1)"
          [ -f "$REL" ] || REL="$(find build/test/android/${ABI}/relwithdebinfo -type f -name BqLogUnitTest | head -n1)"
          echo "dbg=$DBG" >> $GITHUB_OUTPUT
          echo "rel=$REL" >> $GITHUB_OUTPUT

      - name: Create AVD snapshot (if missing)
        uses: reactivecircus/android-emulator-runner@v2
        with:
          api-level: ${{ matrix.api-level }}
          arch: ${{ matrix.abi }}
          disk-size: 6G
          force-avd-creation: true
          emulator-options: -no-window -gpu swiftshader_indirect -noaudio -no-boot-anim -camera-back none
          disable-animations: false
          cores: 4
          script: echo "AVD snapshot created."

      - name: Run tests
        uses: reactivecircus/android-emulator-runner@v2
        with:
          api-level: ${{ matrix.api-level }}
          arch: ${{ matrix.abi }}
          force-avd-creation: false
          emulator-options: -no-snapshot-save -no-window -gpu swiftshader_indirect -noaudio -no-boot-anim -camera-back none
          disable-animations: true
          cores: 4
          script: |
            set -e
            adb devices
            
            # === Debug Test ===
            echo "----------------------------------------"
            echo "Running BqLogUnitTest_dbg"
            echo "----------------------------------------"
            adb push "${{ steps.locate.outputs.dbg }}" /data/local/tmp/BqLogUnitTest_dbg
            adb shell "chmod 755 /data/local/tmp/BqLogUnitTest_dbg"
            
            # Run and write exit code to file on device
            adb shell 'cd /data/local/tmp && TMPDIR=/data/local/tmp ./BqLogUnitTest_dbg; echo $? > exit_code_dbg.txt'
            
            # Pull and check. The check MUST be on one line if variables are used, or use files.
            # We use xargs to trim and [ ... ] to test.
            adb pull /data/local/tmp/exit_code_dbg.txt .
            echo "Debug Test Exit Code: $(cat exit_code_dbg.txt | xargs)"
            [ "$(cat exit_code_dbg.txt | xargs)" = "0" ]
            
            # === Release Test ===
            echo "----------------------------------------"
            echo "Running BqLogUnitTest_rel"
            echo "----------------------------------------"
            adb push "${{ steps.locate.outputs.rel }}" /data/local/tmp/BqLogUnitTest_rel
            adb shell "chmod 755 /data/local/tmp/BqLogUnitTest_rel"
            
            adb shell 'cd /data/local/tmp && TMPDIR=/data/local/tmp ./BqLogUnitTest_rel; echo $? > exit_code_rel.txt'
            
            adb pull /data/local/tmp/exit_code_rel.txt .
            echo "Release Test Exit Code: $(cat exit_code_rel.txt | xargs)"
            [ "$(cat exit_code_rel.txt | xargs)" = "0" ]

  java_wrapper_win64:
    name: java_wrapper (win-${{ matrix.runner.label }}${{ matrix.cc }})
    runs-on: ${{ matrix.runner.runs_on }}
    strategy:
      fail-fast: false
      matrix:
        cc: [ msvc, clang ]
        cpp_ver: [ 11 ]
        runner:
          - label: "x86_64"
            runs_on: windows-latest
          - label: "arm64"
            runs_on: windows-11-arm

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'

      - name: Install Clang(Attempt 1)
        if: ${{ matrix.runner.runs_on == 'windows-11-arm' }}
        continue-on-error: true
        shell: bash
        run: |
          choco uninstall -y llvm --all-versions || true
          choco install -y llvm
      - name: Install Clang(Attempt 2)
        if: ${{ matrix.runner.runs_on == 'windows-11-arm' }}
        continue-on-error: true
        shell: bash
        run: |
          choco install -y llvm
      - name: Install Clang(Attempt 3)
        if: ${{ matrix.runner.runs_on == 'windows-11-arm' }}
        continue-on-error: true
        shell: bash
        run: |
          choco install -y llvm
      - name: Build for Windows
        id: win_run_tests
        shell: powershell
        run: |
          cd build\test\java
          .\run_win

  java_wrapper_mac_silicon:
    name: java_wrapper (macos-latest${{ matrix.asan.label != ' ' && ', ' || '' }}${{ matrix.asan.label }})
    runs-on:  macos-latest
    strategy:
      fail-fast: false
      matrix:
        asan:
          - label: "asan"
            assan_switch: TRUE
          - label: " "
            assan_switch: FALSE
    steps:
      - uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'adopt'

      - name: Test for macOS
        env:
          BQ_ENABLE_ASAN: ${{ matrix.asan.assan_switch }}
        run: |
          cd build/test/java  
          chmod +x *.sh
          ./run_mac.sh

  java_wrapper_ubuntu:
    name: java_wrapper (ubuntu-${{ matrix.runner.label }}${{ matrix.asan.label != ' ' && ', ' || '' }}${{ matrix.asan.label }})
    runs-on: ${{ matrix.runner.runs_on }}
    strategy:
      fail-fast: false
      matrix:
        runner:
          - label: "x86_64"
            runs_on: ubuntu-latest
          - label: "arm64"
            runs_on: ubuntu-24.04-arm
        asan:
          - label: "asan"
            assan_switch: TRUE
          - label: " "
            assan_switch: FALSE
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'adopt'

      - name: Build for Linux
        env:
          BQ_ENABLE_ASAN: ${{ matrix.asan.assan_switch }}
        run: |
          cd build/test/java  
          chmod +x *.sh
          ./run_linux.sh

  java_wrapper_freebsd_x86_64:
    name: java_wrapper (freebsd_x86_64)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Run in FreeBSD
        id: RunInFreeBSD
        uses: vmactions/freebsd-vm@v1
        with:
          usesh: true
          mem: 8192
          prepare: |
            pkg install -y llvm cmake bash openjdk11 gdb gcc

          run: |
            set -e -x
            pkg info -l openjdk11 | grep 'bin/java'
            export JAVA_HOME="/usr/local/openjdk11"
            export PATH="$JAVA_HOME/bin:$PATH"
            echo "JAVA_HOME=$JAVA_HOME" >> $GITHUB_ENV
            echo "PATH=$PATH" >> $GITHUB_ENV
            cd build/test/java  
            chmod +x *.sh
            ./run_unix.sh

  csharp_wrapper_tests:
    name: csharp_wrapper (${{ matrix.label }})
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            script_path: build/test/csharp/run_linux.sh
            asan_switch: TRUE
            label: "ubuntu-latest, asan"
          - os: ubuntu-latest
            script_path: build/test/csharp/run_linux.sh
            asan_switch: FALSE
            label: "ubuntu-latest"
          - os: ubuntu-24.04-arm
            script_path: build/test/csharp/run_linux.sh
            asan_switch: TRUE
            label: "ubuntu-24.04-arm, asan"
          - os: ubuntu-24.04-arm
            script_path: build/test/csharp/run_linux.sh
            asan_switch: FALSE
            label: "ubuntu-24.04-arm"
          - os: macos-latest
            script_path: build/test/csharp/run_mac.sh
            asan_switch: TRUE
            label: "macos-latest, asan"
          - os: macos-latest
            script_path: build/test/csharp/run_mac.sh
            asan_switch: FALSE
            label: "macos-latest"
          - os: windows-latest
            script_path: build/test/csharp/run_win.bat
            shell_type: cmd
            asan_switch: FALSE
            label: "windows-latest"
          - os: windows-11-arm
            script_path: build/test/csharp/run_win.bat
            shell_type: cmd
            asan_switch: FALSE
            label: "windows-11-arm"
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup Dotnet
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x' # Keep 8.0 installed to run tools, even if targeting 3.1
      
      - name: Install CMake
        if: runner.os == 'Windows'
        uses: lukka/get-cmake@latest

      - name: Run C# Tests
        env:
          BQ_ENABLE_ASAN: ${{ matrix.asan_switch }}
        shell: bash
        run: |
          if [ "${{ runner.os }}" == "Windows" ]; then
            ./${{ matrix.script_path }}
          else
            chmod +x ${{ matrix.script_path }}
            ./${{ matrix.script_path }}
          fi

  node_wrapper_tests:
    name: nodejs_wrapper (${{ matrix.label }})
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            script_path: build/test/typescript/run_linux.sh
            asan_switch: TRUE
            label: "ubuntu-latest, asan"
          - os: ubuntu-latest
            script_path: build/test/typescript/run_linux.sh
            asan_switch: FALSE
            label: "ubuntu-latest"
          - os: ubuntu-24.04-arm
            script_path: build/test/typescript/run_linux.sh
            asan_switch: TRUE
            label: "ubuntu-24.04-arm, asan"
          - os: ubuntu-24.04-arm
            script_path: build/test/typescript/run_linux.sh
            asan_switch: FALSE
            label: "ubuntu-24.04-arm"
          - os: macos-latest
            script_path: build/test/typescript/run_mac.sh
            asan_switch: TRUE
            label: "macos-latest, asan"
          - os: macos-latest
            script_path: build/test/typescript/run_mac.sh
            asan_switch: FALSE
            label: "macos-latest"
          - os: windows-latest
            script_path: build/test/typescript/run_win.bat
            shell_type: cmd
            asan_switch: FALSE
            label: "windows-latest"
          - os: windows-11-arm
            script_path: build/test/typescript/run_win.bat
            shell_type: cmd
            asan_switch: FALSE
            label: "windows-11-arm"
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install GDB (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y gdb
          # Stop apport to prevent it from intercepting core dumps
          sudo service apport stop || true

      - name: Run Node Tests
        env:
          BQ_ENABLE_ASAN: ${{ matrix.asan_switch }}
        shell: bash
        run: |
          if [ "${{ runner.os }}" == "Windows" ]; then
            ./${{ matrix.script_path }}
          else
            chmod +x ${{ matrix.script_path }}
            ./${{ matrix.script_path }}
          fi

      - name: Run Node Tests (Linux/macOS)
        if: runner.os != 'Windows'
        run: |
          chmod +x ${{ matrix.script_path }}
          
          # Enable core dumps on Linux
          if [ "$RUNNER_OS" == "Linux" ]; then
            ulimit -c unlimited
            # Try to set core pattern, but don't fail if restricted (e.g. unprivileged container)
            echo "core.%p" | sudo tee /proc/sys/kernel/core_pattern > /dev/null || true
          fi

          set +e
          ./${{ matrix.script_path }}
          EXIT_CODE=$?
          set -e

          if [ $EXIT_CODE -ne 0 ]; then
            echo "Test script failed with exit code $EXIT_CODE"
            
            if [ "$RUNNER_OS" == "Linux" ]; then
              # Search for core files in current dir and /var/crash (apport default)
              CORE_FILE=$(find . -maxdepth 2 -name "core.*" | head -n 1)
              if [ -z "$CORE_FILE" ]; then
                 CORE_FILE=$(find /var/crash -name "*core*" 2>/dev/null | head -n 1)
              fi
              
              if [ -n "$CORE_FILE" ]; then
                echo "Found core dump: $CORE_FILE"
                NODE_BIN=$(which node)
                echo "Generating stack trace..."
                sudo gdb -batch -ex "thread apply all bt full" -ex "quit" "$NODE_BIN" "$CORE_FILE"
              else
                echo "No core dump found."
                # List files to see if we missed anything obvious
                ls -la
              fi
            fi
            exit $EXIT_CODE
          fi

      - name: Run Node Tests (Windows)
        if: runner.os == 'Windows'
        shell: cmd
        run: |
          ${{ matrix.script_path }}


