#pragma once
// clang-format off
/*
 * Copyright (C) 2024 THL A29 Limited, a Tencent company.
 * BQLOG is licensed under the Apache License, Version 2.0.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 */
/*!
 * Generated Wrapper For test_category_log
 *
 * This is a category_log that supports attaching a category to each log entry.
 * Categories can be used to filter logs within the appender settings.
 *
 *  Usage: 
 *  bq::test_category_log my_category_log = bq::test_category_log::create_log(log_name, log_config);  //create a test_category_log object with config.
 *  my_category_log.info("content");  //this is for empty category
 *  my_category_log.info(my_category_log.cat.moduleA.classB, "content"); //this is a log entry for category ModuleA.ClassB. it is generated by your Category Config File
 */

#include "bq_log/bq_log.h"


namespace bq {
    class test_category_log : public category_log
    {
    private:
        template<uint32_t CAT_INDEX>
        struct test_category_log_category_base : public bq::log_category_base<CAT_INDEX> {};

        struct test_category_log_category_config
        {
            const char* names[5] = {
                        ""
                        , "ModuleA"
                        , "ModuleA.SystemA"
                        , "ModuleA.SystemA.ClassA"
                        , "ModuleB"
            };
        };

        struct EBCO test_category_log_category_root
        {
            struct EBCO : public test_category_log_category_base<1> {
                struct EBCO : public test_category_log_category_base<2> {
                    struct EBCO : public test_category_log_category_base<3> {
                    } ClassA;    //ModuleA.SystemA.ClassA
                } SystemA;    //ModuleA.SystemA
            } ModuleA;    //ModuleA
            struct EBCO : public test_category_log_category_base<4> {
            } ModuleB;    //ModuleB
        };

        template<typename T>
        struct test_category_log_category_root_holder
        {
            static test_category_log_category_config config_;
            static test_category_log_category_root root_;
        };

    public:
        const test_category_log_category_root& cat = test_category_log_category_root_holder<void>::root_;

    protected:
        template<typename STR>
        struct is_test_category_log_format_type
        {
            static constexpr bool value = bq::tools::_is_bq_log_format_type<STR>::value;
        };

    private:
        test_category_log() : category_log(){}
        test_category_log(const log& child_inst) : category_log(child_inst){}

    public:
        /// <summary>
        /// Create a test_category_log object
        /// </summary>
        /// <param name="log_name">If the log name is an empty string, bqLog will automatically assign you a unique log name. If the log name already exists, it will return the previously existing log object and overwrite the previous configuration with the new config.</param>
        /// <param name="config_content">Log config string</param>
        /// <returns>A test_category_log object, if create failed, the is_valid() method of it will return false</returns>
        static test_category_log create_log(const bq::string& log_name, const bq::string& config_content);

        /// <summary>
        /// Get a test_category_log object by it's name
        /// </summary>
        /// <param name="log_name">Name of the test_category_log object you want to find</param>
        /// <returns>A test_category_log object, if the test_category_log object with specific name was not found, the is_valid() method of it will return false</returns>
        static test_category_log get_log_by_name(const bq::string& log_name);

        using log::verbose;
        using log::debug;
        using log::info;
        using log::warning;
        using log::error;
        using log::fatal;

        ///Core log functions with category param, there are 6 log levels:
        ///verbose, debug, info, warning, error, fatal
        template<typename STR, uint32_t CAT_INDEX>
        bq::enable_if_t<is_test_category_log_format_type<STR>::value, bool> verbose(const test_category_log_category_base<CAT_INDEX>& category, const STR& log_content) const;
        template<typename STR, uint32_t CAT_INDEX, typename...Args>
        bq::enable_if_t<is_test_category_log_format_type<STR>::value, bool> verbose(const test_category_log_category_base<CAT_INDEX>& category, const STR& log_format_content, const Args&... args) const;
        template<typename STR, uint32_t CAT_INDEX>
        bq::enable_if_t<is_test_category_log_format_type<STR>::value, bool> debug(const test_category_log_category_base<CAT_INDEX>& category, const STR& log_content) const;
        template<typename STR, uint32_t CAT_INDEX, typename...Args>
        bq::enable_if_t<is_test_category_log_format_type<STR>::value, bool> debug(const test_category_log_category_base<CAT_INDEX>& category, const STR& log_format_content, const Args&... args) const;
        template<typename STR, uint32_t CAT_INDEX>
        bq::enable_if_t<is_test_category_log_format_type<STR>::value, bool> info(const test_category_log_category_base<CAT_INDEX>& category, const STR& log_content) const;
        template<typename STR, uint32_t CAT_INDEX, typename...Args>
        bq::enable_if_t<is_test_category_log_format_type<STR>::value, bool> info(const test_category_log_category_base<CAT_INDEX>& category, const STR& log_format_content, const Args&... args) const;
        template<typename STR, uint32_t CAT_INDEX>
        bq::enable_if_t<is_test_category_log_format_type<STR>::value, bool> warning(const test_category_log_category_base<CAT_INDEX>& category, const STR& log_content) const;
        template<typename STR, uint32_t CAT_INDEX, typename...Args>
        bq::enable_if_t<is_test_category_log_format_type<STR>::value, bool> warning(const test_category_log_category_base<CAT_INDEX>& category, const STR& log_format_content, const Args&... args) const;
        template<typename STR, uint32_t CAT_INDEX>
        bq::enable_if_t<is_test_category_log_format_type<STR>::value, bool> error(const test_category_log_category_base<CAT_INDEX>& category, const STR& log_content) const;
        template<typename STR, uint32_t CAT_INDEX, typename...Args>
        bq::enable_if_t<is_test_category_log_format_type<STR>::value, bool> error(const test_category_log_category_base<CAT_INDEX>& category, const STR& log_format_content, const Args&... args) const;
        template<typename STR, uint32_t CAT_INDEX>
        bq::enable_if_t<is_test_category_log_format_type<STR>::value, bool> fatal(const test_category_log_category_base<CAT_INDEX>& category, const STR& log_content) const;
        template<typename STR, uint32_t CAT_INDEX, typename...Args>
        bq::enable_if_t<is_test_category_log_format_type<STR>::value, bool> fatal(const test_category_log_category_base<CAT_INDEX>& category, const STR& log_format_content, const Args&... args) const;
    };

    template<typename T>
    test_category_log::test_category_log_category_root test_category_log::test_category_log_category_root_holder<T>::root_;
    template<typename T>
    test_category_log::test_category_log_category_config test_category_log::test_category_log_category_root_holder<T>::config_;

    inline test_category_log test_category_log::create_log(const bq::string& log_name, const bq::string& config_content)
    {
        uint64_t log_id = api::__api_create_log(log_name.c_str(), config_content.c_str(), 5, test_category_log_category_root_holder<void>::config_.names);
        log result = get_log_by_id(log_id);
        return result;
    }
    
    inline test_category_log test_category_log::get_log_by_name(const bq::string& log_name)
    {
        test_category_log result = log::get_log_by_name(log_name);
        if (!result.is_valid())
        {
            return result;
        }
        //check categories
        if (result.get_categories_count() != 5)
        {
            return test_category_log();
        }
        for (size_t i = 0; i < result.get_categories_count(); ++i)
        {
            if (result.get_categories_name_array()[i] != test_category_log_category_root_holder<void>::config_.names[i])
            {
                return test_category_log();
            }
        }
        return result;
    }

    template<typename STR, uint32_t CAT_INDEX>
    inline bq::enable_if_t<test_category_log::is_test_category_log_format_type<STR>::value, bool> test_category_log::verbose(const test_category_log::test_category_log_category_base<CAT_INDEX>& category, const STR& log_content) const
    {
        (void)category;
        return do_log(CAT_INDEX, log_level::verbose, log_content);
    }
    template<typename STR, uint32_t CAT_INDEX, typename...Args>
    inline bq::enable_if_t<test_category_log::is_test_category_log_format_type<STR>::value, bool> test_category_log::verbose(const test_category_log::test_category_log_category_base<CAT_INDEX>& category, const STR& log_format_content, const Args&... args) const
    {
        (void)category;
        return do_log(CAT_INDEX, log_level::verbose, log_format_content, args...);
    }
    template<typename STR, uint32_t CAT_INDEX>
    inline bq::enable_if_t<test_category_log::is_test_category_log_format_type<STR>::value, bool> test_category_log::debug(const test_category_log::test_category_log_category_base<CAT_INDEX>& category, const STR& log_content) const
    {
        (void)category;
        return do_log(CAT_INDEX, log_level::debug, log_content);
    }
    template<typename STR, uint32_t CAT_INDEX, typename...Args>
    inline bq::enable_if_t<test_category_log::is_test_category_log_format_type<STR>::value, bool> test_category_log::debug(const test_category_log::test_category_log_category_base<CAT_INDEX>& category, const STR& log_format_content, const Args&... args) const
    {
        (void)category;
        return do_log(CAT_INDEX, log_level::debug, log_format_content, args...);
    }
    template<typename STR, uint32_t CAT_INDEX>
    inline bq::enable_if_t<test_category_log::is_test_category_log_format_type<STR>::value, bool> test_category_log::info(const test_category_log::test_category_log_category_base<CAT_INDEX>& category, const STR& log_content) const
    {
        (void)category;
        return do_log(CAT_INDEX, log_level::info, log_content);
    }
    template<typename STR, uint32_t CAT_INDEX, typename...Args>
    inline bq::enable_if_t<test_category_log::is_test_category_log_format_type<STR>::value, bool> test_category_log::info(const test_category_log::test_category_log_category_base<CAT_INDEX>& category, const STR& log_format_content, const Args&... args) const
    {
        (void)category;
        return do_log(CAT_INDEX, log_level::info, log_format_content, args...);
    }
    template<typename STR, uint32_t CAT_INDEX>
    inline bq::enable_if_t<test_category_log::is_test_category_log_format_type<STR>::value, bool> test_category_log::warning(const test_category_log::test_category_log_category_base<CAT_INDEX>& category, const STR& log_content) const
    {
        (void)category;
        return do_log(CAT_INDEX, log_level::warning, log_content);
    }
    template<typename STR, uint32_t CAT_INDEX, typename...Args>
    inline bq::enable_if_t<test_category_log::is_test_category_log_format_type<STR>::value, bool> test_category_log::warning(const test_category_log::test_category_log_category_base<CAT_INDEX>& category, const STR& log_format_content, const Args&... args) const
    {
        (void)category;
        return do_log(CAT_INDEX, log_level::warning, log_format_content, args...);
    }
    template<typename STR, uint32_t CAT_INDEX>
    inline bq::enable_if_t<test_category_log::is_test_category_log_format_type<STR>::value, bool> test_category_log::error(const test_category_log::test_category_log_category_base<CAT_INDEX>& category, const STR& log_content) const
    {
        (void)category;
        return do_log(CAT_INDEX, log_level::error, log_content);
    }
    template<typename STR, uint32_t CAT_INDEX, typename...Args>
    inline bq::enable_if_t<test_category_log::is_test_category_log_format_type<STR>::value, bool> test_category_log::error(const test_category_log::test_category_log_category_base<CAT_INDEX>& category, const STR& log_format_content, const Args&... args) const
    {
        (void)category;
        return do_log(CAT_INDEX, log_level::error, log_format_content, args...);
    }
    template<typename STR, uint32_t CAT_INDEX>
    inline bq::enable_if_t<test_category_log::is_test_category_log_format_type<STR>::value, bool> test_category_log::fatal(const test_category_log::test_category_log_category_base<CAT_INDEX>& category, const STR& log_content) const
    {
        (void)category;
        return do_log(CAT_INDEX, log_level::fatal, log_content);
    }
    template<typename STR, uint32_t CAT_INDEX, typename...Args>
    inline bq::enable_if_t<test_category_log::is_test_category_log_format_type<STR>::value, bool> test_category_log::fatal(const test_category_log::test_category_log_category_base<CAT_INDEX>& category, const STR& log_format_content, const Args&... args) const
    {
        (void)category;
        return do_log(CAT_INDEX, log_level::fatal, log_format_content, args...);
    }
}
// clang-format on
