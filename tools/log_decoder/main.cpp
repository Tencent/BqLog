/*
 * Copyright (C) 2025 Tencent.
 * BQLOG is licensed under the Apache License, Version 2.0.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 */
#include "bq_common/bq_common.h"
#include "bq_log/bq_log.h"
#include "bq_log/log/appender/appender_file_compressed.h"
#include "bq_log/log/appender/appender_file_raw.h"
#include "common_header.h"

struct Options {
    bq::string input_path;
    bq::string output_path;    // "-" or empty => stdout
    bq::string private_key_path; // File path to RSA-2048 PEM private key
    bool show_help = false;
    bool show_version = false;
};

#define CONSOLE_OUTPUT(level, /* format, ... */ ...) \
    do { \
        bq::util::set_log_device_console_min_level(bq::log_level::verbose); \
        bq::util::log_device_console((level), __VA_ARGS__); \
        bq::util::set_log_device_console_min_level(bq::log_level::error); \
    } while (0)

static void print_version() {
    CONSOLE_OUTPUT(bq::log_level::debug, "Supported appender format versions:");
    CONSOLE_OUTPUT(bq::log_level::debug, "  raw file format version:        %" PRIu32 "", bq::appender_file_raw::format_version);
    CONSOLE_OUTPUT(bq::log_level::debug, "  compressed file format version:        %" PRIu32 "", bq::appender_file_compressed::format_version);
}

static void print_help(const char* prog) {
    bq::string output = bq::string("")
        + "Usage:\n"
        + "  " + prog + " [OPTIONS] <input_log_file>\n"
        + "\n"
        + "Decode a binary BqLog file to text.\n"
        + "\n"
        + "Options:\n"
        + "  -o, --output PATH     Write decoded text to PATH (default: stdout)\n"
        + "  -k, --key PATH        RSA private key file generated by ssh-keygen\n"
        + "                        (RSA-2048, PEM format). Example:\n"
        + "                          ssh-keygen -t rsa -b 2048 -m PEM -f private_key\n"
        + "  -h, --help            Show this help and exit\n"
        + "  -V, --version         Show version and supported format versions, then exit\n"
        + "\n\n"
        + "Notes:\n"
        + "  - Encrypted (passphrase-protected) private keys are not supported currently.\n"
        + "    If your key is in OpenSSH format (\"BEGIN OPENSSH PRIVATE KEY\"), convert it to\n"
        + "    PEM with: ssh-keygen -p -m PEM -N \"\" -f private_key\n"
        + "\n"
        + "Examples:\n"
        + "  " + prog + " input.logcompr\n"
        + "  " + prog + " input.logcompr -o output.txt\n"
        + "  " + prog + " input.logcompr -k private_key\n";
    CONSOLE_OUTPUT(bq::log_level::debug, "%s", output.c_str());
}

static bool parse_args(int argc, char* argv[], Options& opt) {
    if (argc <= 1) {
        opt.show_help = true;
        return true;
    }
    for (int i = 1; i < argc; ++i) {
        const bq::string arg(argv[i]);
        if (arg == "-h" || arg == "--help") {
            opt.show_help = true;
            return true;
        }
        else if (arg == "-V" || arg == "--version") {
            opt.show_version = true;
            return true;
        }
        else if (arg == "-o" || arg == "--output") {
            if (i + 1 >= argc) {
                CONSOLE_OUTPUT(bq::log_level::error, "error: missing value for %s\n", arg.c_str());
                return false;
            }
            opt.output_path = argv[++i];
        }
        else if (arg.find("--output=", 0) == 0) {
            opt.output_path = arg.substr(strlen("--output="));
        }
        else if (arg == "-k" || arg == "--key") {
            if (i + 1 >= argc) {
                CONSOLE_OUTPUT(bq::log_level::error, "error: missing value for %s\n", arg.c_str());
                return false;
            }
            opt.private_key_path = argv[++i];
        }
        else if (arg.find("--key=", 0) == 0) {
            opt.private_key_path = arg.substr(strlen("--key="));
        }
        else if (!arg.is_empty() && arg[0] == '-') {
            CONSOLE_OUTPUT(bq::log_level::error, "error: unknown option '%s'\n", arg.c_str());
            return false;
        }
        else {
            if (!opt.input_path.is_empty()) {
                CONSOLE_OUTPUT(bq::log_level::error, "error: multiple input files provided: '%s' and '%s'\n",
                    opt.input_path.c_str(), arg.c_str());
                return false;
            }
            opt.input_path = arg;
        }
    }
    if (!opt.show_help && !opt.show_version && opt.input_path.is_empty()) {
        CONSOLE_OUTPUT(bq::log_level::error, "error: missing required <input_log_file>\n");
        return false;
    }
    return true;
}

static bool looks_like_openssh_format(const bq::string& key) {
    return key.find("BEGIN OPENSSH PRIVATE KEY") != bq::string::npos;
}
static bool looks_like_pem_pkcs1(const bq::string& key) {
    
    return key.find("BEGIN RSA PRIVATE KEY") != bq::string::npos;
}

int32_t main(int32_t argc, char* argv[]) {
    Options opt;
    if (!parse_args(argc, argv, opt)) {
        print_help(argv[0]);
        return 2; // bad usage
    }
    if (opt.show_help) {
        print_help(argv[0]);
        return 0;
    }
    if (opt.show_version) {
        print_version();
        return 0;
    }

    bq::string priv_key_str;
    // Load private key if provided (PEM; unencrypted).
    if (!opt.private_key_path.is_empty() && opt.private_key_path != "-") {
        bq::string abs_key_path = TO_ABSOLUTE_PATH(opt.private_key_path, 1);
        priv_key_str = bq::file_manager::instance().read_all_text(abs_key_path);
        if (priv_key_str.is_empty()) {
            CONSOLE_OUTPUT(bq::log_level::error, "error: failed to read private key file: %s\n", abs_key_path.c_str());
            return 3;
        }
        if (looks_like_openssh_format(priv_key_str)) {
            CONSOLE_OUTPUT(bq::log_level::error, "error: unsupported key format: OpenSSH private key.\n"
                "       Please convert to PEM (RSA-2048) with:\n"
                "         ssh-keygen -p -m PEM -N \"\" -f %s\n", abs_key_path.c_str());
            return 3;
        }
        if (!looks_like_pem_pkcs1(priv_key_str)) {
            CONSOLE_OUTPUT(bq::log_level::error, "error: unsupported key format: not PEM (PKCS#1).\n"
                "       Please convert to PEM (RSA-2048) with:\n"
                "         ssh-keygen -p -m PEM -N \"\" -f %s\n", abs_key_path.c_str());
        }
    }

    if (!opt.output_path.is_empty()) {
        bool ret = bq::tools::log_decoder::decode_file(opt.input_path, opt.output_path, priv_key_str);
        if (!ret) {
            CONSOLE_OUTPUT(bq::log_level::error, "Failed to decode log file: %s", TO_ABSOLUTE_PATH(opt.input_path, 1).c_str());
            return 1;
        }
        CONSOLE_OUTPUT(bq::log_level::info, "Successfully decoded! see output:%s", TO_ABSOLUTE_PATH(opt.output_path, 1).c_str());
        return 0;
    }

    // Open output if requested.
    bq::tools::log_decoder decoder(opt.input_path, priv_key_str);
    bq::string output_cache;
    while (true) {
        auto decode_result = decoder.decode();
        if (decode_result == bq::appender_decode_result::eof) {
            CONSOLE_OUTPUT(bq::log_level::debug, "%s", output_cache.c_str());
            output_cache.clear();
            break;
        }
        else if (decode_result != bq::appender_decode_result::success) {
            CONSOLE_OUTPUT(bq::log_level::error, "error: decode failed, reason:%" PRId32 "", static_cast<int32_t>(decoder.get_last_decode_result()));
            return -1 * static_cast<int32_t>(decode_result);
        }
        output_cache += decoder.get_last_decoded_log_entry();
        output_cache.push_back('\n');
        if (output_cache.size() > 4 * 1024) { // Flush every 4K
            CONSOLE_OUTPUT(bq::log_level::debug, "%s", output_cache.c_str());
            output_cache.clear();
        }
    }

    return 0;
}