/*
 * Copyright (C) 2025 Tencent.
 * BQLOG is licensed under the Apache License, Version 2.0.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 */
#include "template/category_log_template_typescript.h"

namespace bq {
    const static char* TAB = "    ";
    bq::string category_log_template_typescript::format(const bq::string& template_string, const category_node& root_node) const
    {
        bq::string generated_code = template_string;
        generated_code = replace_with_tab_format(generated_code, "${CLASS_NAME}", class_name_);
        generated_code = replace_with_tab_format(generated_code, "${CATEGORY_NAMES}", get_category_names_code(root_node));
        generated_code = replace_with_tab_format(generated_code, "${CATEGORY_ROOT_CLASS}", get_category_class_root_define_code(root_node));

        return generated_code;
    }

    bq::string category_log_template_typescript::get_category_names_code_recursive(const category_node& node) const
    {
        bq::string tab = "    ";
        bq::string code = tab;
        if (node.parent()) // empty means it is root node, first value
        {
            code += ", ";
        }
        code += "\"" + node.full_name() + "\"\n";
        for (const auto& child : node.get_all_children()) {
            code += get_category_names_code_recursive(*child);
        }
        return code;
    }
    bq::string category_log_template_typescript::get_category_class_code_recursive(const category_node& node, const bq::string& tab, uint64_t& index) const
    {
        bq::string node_class_name = class_name_ + "_" + node.name();
        bq::string code = tab + "public readonly " + node.name() + " = new (class " + node_class_name + " extends " + class_name_ + "_category_base {\n";
        code += tab + TAB + "constructor() {\n";
        code += tab + TAB + TAB + "super(" + uint64_to_string(++index) + ");\n";
        code += tab + TAB + "}\n";
        for (const auto& child : node.get_all_children()) {
            code += get_category_class_code_recursive(*child, tab + TAB, index);
        }
        code += tab + "})();\n";
        return code;
    }

    bq::string category_log_template_typescript::get_category_names_code(const category_node& root_node) const
    {
        bq::string code = "[\n";
        code += get_category_names_code_recursive(root_node);
        code += "]";
        return code;
    }

    bq::string category_log_template_typescript::get_category_class_root_define_code(const category_node& root_node) const
    {
        bq::string code = "class  " + class_name_ + "_category_root\n";
        code += "{\n";
        uint64_t index = 0;
        for (const auto& child : root_node.get_all_children()) {
            code += get_category_class_code_recursive(*child, "    ", index);
        }
        code += "}\n";
        return code;
    }

    bq::string category_log_template_typescript::get_template_content() const
    {
        return R"(
        /*
         * Copyright (C) 2025 Tencent.
         * BQLOG is licensed under the Apache License, Version 2.0.
         * You may obtain a copy of the License at
         *
         *     http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         */

        /*!
         * Generated Wrapper For demo_category_log (TypeScript)
         *
         * A category_log that supports attaching a category to each log entry.
         * Categories can be used to filter logs within the appender settings.
         *
         * Usage:
         *   let myLog = demo_category_log.create_log(name, cfg);
         *   myLog.info("no category %d", 1);
         *   myLog.info(myLog.cat.node_3.node_6, "with category %s", "ok");
         */

        /****************************************************************************************************************/
        /**                                 Code Generated By Categories                                              **/
        /****************************************************************************************************************/

        // ESM and TypeScript (TS will compile this to require when module=CommonJS)
        import { bq } from "bqlog";

        // Plain Node CommonJS (no "type":"module"): use this instead
        // const { bq } = require("bqlog");

        class ${CLASS_NAME}_category_base extends bq.log_category_base {
            protected constructor(index: number) {
                super(index);
            }
        }

        
        ${CATEGORY_ROOT_CLASS}

        export class ${CLASS_NAME} extends bq.category_log {
            private static readonly category_names: string[] = ${CATEGORY_NAMES};
            private static readonly categories_count: number = ${CLASS_NAME}.category_names.length;

            public readonly cat = new ${CLASS_NAME}_category_root();

            protected constructor(arg: ${CLASS_NAME} | bigint) {
                super(arg as any);
            }

            public declare get_categories_count: () => number;
            public declare get_categories_name_array: () => string[];

            /**
             * Create a log object
             * @param name 
             *             If the log name is an empty string, bqLog will automatically assign you a unique name. 
             *             If the log name already exists, it will return the previously existing log object and overwrite the previous configuration with the new config.
             * @param config
             *             log config string
             * @return
             *             A log object, if create failed, the is_valid() method of it will return false
             */
            public static create_log(name: string, config: string): ${CLASS_NAME} {

                let default_log = bq.category_log.call_api_create_category_log(name, config, ${CLASS_NAME}.categories_count, ${CLASS_NAME}.category_names);
                let result = new ${CLASS_NAME}(default_log as any);
                //check categories
                if (result.get_categories_count() != ${CLASS_NAME}.categories_count) {
                    console.log("expected:" + ${CLASS_NAME}.categories_count + ", but:" + result.get_categories_count());

                    return new ${CLASS_NAME}(0n);
                }
                for (let i = 0; i < result.get_categories_count(); ++i) {
                    if (${CLASS_NAME}.category_names[i] != ${CLASS_NAME}.category_names[i]) {
                        return new ${CLASS_NAME}(0n);
                    }
                }
                return result;
            }

            /**
             * Get a log object by it's name
             * @param log_name
             * 			Name of the log you want to find
             * @return
             * 			A log object, if the log object with specific name was not found, the is_valid() method of it will return false
             */
            public static get_log_by_name(log_name: string): ${CLASS_NAME} {

                let default_log = bq.log.get_log_by_name(log_name);
                return new ${CLASS_NAME}(default_log as any);
            }

            // ======== Overloads: each function supports both modes you requested ========
            public declare verbose: (typeof bq.log.prototype.verbose) & ((cat: ${CLASS_NAME}_category_base, log_format_content: string, ...args: unknown[]) => boolean);
            public declare debug: (typeof bq.log.prototype.debug) & ((cat: ${CLASS_NAME}_category_base, log_format_content: string, ...args: unknown[]) => boolean);
            public declare info: (typeof bq.log.prototype.info) & ((cat: ${CLASS_NAME}_category_base, log_format_content: string, ...args: unknown[]) => boolean);
            public declare warning: (typeof bq.log.prototype.warning) & ((cat: ${CLASS_NAME}_category_base, log_format_content: string, ...args: unknown[]) => boolean);
            public declare error: (typeof bq.log.prototype.error) & ((cat: ${CLASS_NAME}_category_base, log_format_content: string, ...args: unknown[]) => boolean);
            public declare fatal: (typeof bq.log.prototype.fatal) & ((cat: ${CLASS_NAME}_category_base, log_format_content: string, ...args: unknown[]) => boolean);
        }
        )";
    }
}
