#pragma once
// clang-format off
/*
 * Copyright (C) 2024 THL A29 Limited, a Tencent company.
 * BQLOG is licensed under the Apache License, Version 2.0.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 */
/*!
 * Generated Wrapper For demo_category_log
 *
 * This is a category_log that supports attaching a category to each log entry.
 * Categories can be used to filter logs within the appender settings.
 *
 *  Usage: 
 *  bq::demo_category_log my_category_log = bq::demo_category_log::create_log(log_name, log_config);  //create a demo_category_log object with config.
 *  my_category_log.info("content");  //this is for empty category
 *  my_category_log.info(my_category_log.cat.moduleA.classB, "content"); //this is a log entry for category ModuleA.ClassB. it is generated by your Category Config File
 */

#include "bq_log/bq_log.h"


namespace bq {
    class demo_category_log : public category_log
    {
    private:
        template<uint32_t CAT_INDEX>
        struct demo_category_log_category_base : public bq::log_category_base<CAT_INDEX> {};

        struct demo_category_log_category_config
        {
            const char* names[10] = {
                        ""
                        , "node_2"
                        , "node_2.node_5"
                        , "node_3"
                        , "node_3.node_6"
                        , "node_3.node_10"
                        , "node_4"
                        , "node_4.node_7"
                        , "node_4.node_7.node_8"
                        , "node_4.node_7.node_9"
            };
        };

        struct EBCO demo_category_log_category_root
        {
            struct EBCO : public demo_category_log_category_base<1> {
                struct EBCO : public demo_category_log_category_base<2> {
                } node_5;    //node_2.node_5
            } node_2;    //node_2
            struct EBCO : public demo_category_log_category_base<3> {
                struct EBCO : public demo_category_log_category_base<4> {
                } node_6;    //node_3.node_6    //comment Test
                struct EBCO : public demo_category_log_category_base<5> {
                } node_10;    //node_3.node_10
            } node_3;    //node_3
            struct EBCO : public demo_category_log_category_base<6> {
                struct EBCO : public demo_category_log_category_base<7> {
                    struct EBCO : public demo_category_log_category_base<8> {
                    } node_8;    //node_4.node_7.node_8
                    struct EBCO : public demo_category_log_category_base<9> {
                    } node_9;    //node_4.node_7.node_9
                } node_7;    //node_4.node_7
            } node_4;    //node_4
        };

        template<typename T>
        struct demo_category_log_category_root_holder
        {
            static demo_category_log_category_config config_;
            static demo_category_log_category_root root_;
        };

    public:
        const demo_category_log_category_root& cat = demo_category_log_category_root_holder<void>::root_;

    protected:
        template<typename STR>
        struct is_demo_category_log_format_type
        {
            static constexpr bool value = bq::tools::_is_bq_log_format_type<STR>::value;
        };

    private:
        demo_category_log() : category_log(){}
        demo_category_log(const log& child_inst) : category_log(child_inst){}

    public:
        /// <summary>
        /// Create a demo_category_log object
        /// </summary>
        /// <param name="log_name">If the log name is an empty string, bqLog will automatically assign you a unique log name. If the log name already exists, it will return the previously existing log object and overwrite the previous configuration with the new config.</param>
        /// <param name="config_content">Log config string</param>
        /// <returns>A demo_category_log object, if create failed, the is_valid() method of it will return false</returns>
        static demo_category_log create_log(const bq::string& log_name, const bq::string& config_content);

        /// <summary>
        /// Get a demo_category_log object by it's name
        /// </summary>
        /// <param name="log_name">Name of the demo_category_log object you want to find</param>
        /// <returns>A demo_category_log object, if the demo_category_log object with specific name was not found, the is_valid() method of it will return false</returns>
        static demo_category_log get_log_by_name(const bq::string& log_name);

        using log::verbose;
        using log::debug;
        using log::info;
        using log::warning;
        using log::error;
        using log::fatal;

        ///Core log functions with category param, there are 6 log levels:
        ///verbose, debug, info, warning, error, fatal
        template<typename STR, uint32_t CAT_INDEX>
        bq::enable_if_t<is_demo_category_log_format_type<STR>::value, bool> verbose(const demo_category_log_category_base<CAT_INDEX>& cat, const STR& log_content) const;
        template<typename STR, uint32_t CAT_INDEX, typename...Args>
        bq::enable_if_t<is_demo_category_log_format_type<STR>::value, bool> verbose(const demo_category_log_category_base<CAT_INDEX>& cat, const STR& log_format_content, const Args&... args) const;
        template<typename STR, uint32_t CAT_INDEX>
        bq::enable_if_t<is_demo_category_log_format_type<STR>::value, bool> debug(const demo_category_log_category_base<CAT_INDEX>& cat, const STR& log_content) const;
        template<typename STR, uint32_t CAT_INDEX, typename...Args>
        bq::enable_if_t<is_demo_category_log_format_type<STR>::value, bool> debug(const demo_category_log_category_base<CAT_INDEX>& cat, const STR& log_format_content, const Args&... args) const;
        template<typename STR, uint32_t CAT_INDEX>
        bq::enable_if_t<is_demo_category_log_format_type<STR>::value, bool> info(const demo_category_log_category_base<CAT_INDEX>& cat, const STR& log_content) const;
        template<typename STR, uint32_t CAT_INDEX, typename...Args>
        bq::enable_if_t<is_demo_category_log_format_type<STR>::value, bool> info(const demo_category_log_category_base<CAT_INDEX>& cat, const STR& log_format_content, const Args&... args) const;
        template<typename STR, uint32_t CAT_INDEX>
        bq::enable_if_t<is_demo_category_log_format_type<STR>::value, bool> warning(const demo_category_log_category_base<CAT_INDEX>& cat, const STR& log_content) const;
        template<typename STR, uint32_t CAT_INDEX, typename...Args>
        bq::enable_if_t<is_demo_category_log_format_type<STR>::value, bool> warning(const demo_category_log_category_base<CAT_INDEX>& cat, const STR& log_format_content, const Args&... args) const;
        template<typename STR, uint32_t CAT_INDEX>
        bq::enable_if_t<is_demo_category_log_format_type<STR>::value, bool> error(const demo_category_log_category_base<CAT_INDEX>& cat, const STR& log_content) const;
        template<typename STR, uint32_t CAT_INDEX, typename...Args>
        bq::enable_if_t<is_demo_category_log_format_type<STR>::value, bool> error(const demo_category_log_category_base<CAT_INDEX>& cat, const STR& log_format_content, const Args&... args) const;
        template<typename STR, uint32_t CAT_INDEX>
        bq::enable_if_t<is_demo_category_log_format_type<STR>::value, bool> fatal(const demo_category_log_category_base<CAT_INDEX>& cat, const STR& log_content) const;
        template<typename STR, uint32_t CAT_INDEX, typename...Args>
        bq::enable_if_t<is_demo_category_log_format_type<STR>::value, bool> fatal(const demo_category_log_category_base<CAT_INDEX>& cat, const STR& log_format_content, const Args&... args) const;
    };

    template<typename T>
    demo_category_log::demo_category_log_category_root demo_category_log::demo_category_log_category_root_holder<T>::root_;
    template<typename T>
    demo_category_log::demo_category_log_category_config demo_category_log::demo_category_log_category_root_holder<T>::config_;

    inline demo_category_log demo_category_log::create_log(const bq::string& log_name, const bq::string& config_content)
    {
        uint64_t log_id = api::__api_create_log(log_name.c_str(), config_content.c_str(), 10, demo_category_log_category_root_holder<void>::config_.names);
        log result = get_log_by_id(log_id);
        return result;
    }
    
    inline demo_category_log demo_category_log::get_log_by_name(const bq::string& log_name)
    {
        demo_category_log result = log::get_log_by_name(log_name);
        if (!result.is_valid())
        {
            return result;
        }
        //check categories
        if (result.get_categories_count() != 10)
        {
            return demo_category_log();
        }
        for (size_t i = 0; i < result.get_categories_count(); ++i)
        {
            if (result.get_categories_name_array()[i] != demo_category_log_category_root_holder<void>::config_.names[i])
            {
                return demo_category_log();
            }
        }
        return result;
    }

    template<typename STR, uint32_t CAT_INDEX>
    inline bq::enable_if_t<demo_category_log::is_demo_category_log_format_type<STR>::value, bool> demo_category_log::verbose(const demo_category_log::demo_category_log_category_base<CAT_INDEX>& cat, const STR& log_content) const
    {
        (void)cat;
        return do_log(CAT_INDEX, log_level::verbose, log_content);
    }
    template<typename STR, uint32_t CAT_INDEX, typename...Args>
    inline bq::enable_if_t<demo_category_log::is_demo_category_log_format_type<STR>::value, bool> demo_category_log::verbose(const demo_category_log::demo_category_log_category_base<CAT_INDEX>& cat, const STR& log_format_content, const Args&... args) const
    {
        (void)cat;
        return do_log(CAT_INDEX, log_level::verbose, log_format_content, args...);
    }
    template<typename STR, uint32_t CAT_INDEX>
    inline bq::enable_if_t<demo_category_log::is_demo_category_log_format_type<STR>::value, bool> demo_category_log::debug(const demo_category_log::demo_category_log_category_base<CAT_INDEX>& cat, const STR& log_content) const
    {
        (void)cat;
        return do_log(CAT_INDEX, log_level::debug, log_content);
    }
    template<typename STR, uint32_t CAT_INDEX, typename...Args>
    inline bq::enable_if_t<demo_category_log::is_demo_category_log_format_type<STR>::value, bool> demo_category_log::debug(const demo_category_log::demo_category_log_category_base<CAT_INDEX>& cat, const STR& log_format_content, const Args&... args) const
    {
        (void)cat;
        return do_log(CAT_INDEX, log_level::debug, log_format_content, args...);
    }
    template<typename STR, uint32_t CAT_INDEX>
    inline bq::enable_if_t<demo_category_log::is_demo_category_log_format_type<STR>::value, bool> demo_category_log::info(const demo_category_log::demo_category_log_category_base<CAT_INDEX>& cat, const STR& log_content) const
    {
        (void)cat;
        return do_log(CAT_INDEX, log_level::info, log_content);
    }
    template<typename STR, uint32_t CAT_INDEX, typename...Args>
    inline bq::enable_if_t<demo_category_log::is_demo_category_log_format_type<STR>::value, bool> demo_category_log::info(const demo_category_log::demo_category_log_category_base<CAT_INDEX>& cat, const STR& log_format_content, const Args&... args) const
    {
        (void)cat;
        return do_log(CAT_INDEX, log_level::info, log_format_content, args...);
    }
    template<typename STR, uint32_t CAT_INDEX>
    inline bq::enable_if_t<demo_category_log::is_demo_category_log_format_type<STR>::value, bool> demo_category_log::warning(const demo_category_log::demo_category_log_category_base<CAT_INDEX>& cat, const STR& log_content) const
    {
        (void)cat;
        return do_log(CAT_INDEX, log_level::warning, log_content);
    }
    template<typename STR, uint32_t CAT_INDEX, typename...Args>
    inline bq::enable_if_t<demo_category_log::is_demo_category_log_format_type<STR>::value, bool> demo_category_log::warning(const demo_category_log::demo_category_log_category_base<CAT_INDEX>& cat, const STR& log_format_content, const Args&... args) const
    {
        (void)cat;
        return do_log(CAT_INDEX, log_level::warning, log_format_content, args...);
    }
    template<typename STR, uint32_t CAT_INDEX>
    inline bq::enable_if_t<demo_category_log::is_demo_category_log_format_type<STR>::value, bool> demo_category_log::error(const demo_category_log::demo_category_log_category_base<CAT_INDEX>& cat, const STR& log_content) const
    {
        (void)cat;
        return do_log(CAT_INDEX, log_level::error, log_content);
    }
    template<typename STR, uint32_t CAT_INDEX, typename...Args>
    inline bq::enable_if_t<demo_category_log::is_demo_category_log_format_type<STR>::value, bool> demo_category_log::error(const demo_category_log::demo_category_log_category_base<CAT_INDEX>& cat, const STR& log_format_content, const Args&... args) const
    {
        (void)cat;
        return do_log(CAT_INDEX, log_level::error, log_format_content, args...);
    }
    template<typename STR, uint32_t CAT_INDEX>
    inline bq::enable_if_t<demo_category_log::is_demo_category_log_format_type<STR>::value, bool> demo_category_log::fatal(const demo_category_log::demo_category_log_category_base<CAT_INDEX>& cat, const STR& log_content) const
    {
        (void)cat;
        return do_log(CAT_INDEX, log_level::fatal, log_content);
    }
    template<typename STR, uint32_t CAT_INDEX, typename...Args>
    inline bq::enable_if_t<demo_category_log::is_demo_category_log_format_type<STR>::value, bool> demo_category_log::fatal(const demo_category_log::demo_category_log_category_base<CAT_INDEX>& cat, const STR& log_format_content, const Args&... args) const
    {
        (void)cat;
        return do_log(CAT_INDEX, log_level::fatal, log_format_content, args...);
    }
}
// clang-format on
